{"rating":{"max":10,"numRaters":81,"average":"9.2","min":0},"subtitle":"","author":["Nicolai M. Josuttis"],"pubdate":"2015-6","tags":[{"count":135,"name":"C++","title":"C++"},{"count":62,"name":"标准库","title":"标准库"},{"count":44,"name":"STL","title":"STL"},{"count":41,"name":"计算机","title":"计算机"},{"count":35,"name":"C++11","title":"C++11"},{"count":34,"name":"C\/C++","title":"C\/C++"},{"count":27,"name":"编程","title":"编程"},{"count":19,"name":"经典","title":"经典"}],"origin_title":"The C++ Standard Library: A Tutorial and Reference","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28104600.jpg","binding":"平装","translator":["侯捷"],"catalog":"第 2 版译序\txxi\n第 2 版序言\txxiii\n第 2 版致谢\txxiv\n第 1 版序言\txxv\n第 1 版致谢\txxvi\n1 关于本书\t1\n1.1 缘起\t1\n1.2 阅读前的必要基础\t2\n1.3 本书风格与结构\t2\n1.4 如何阅读本书\t4\n1.5 目前发展情势\t5\n1.6 范例代码及额外信息\t5\n1.7 反馈\t5\n2 C++ 及标准库简介\t7\n2.1 C++ Standard 的历史\t7\n2.1.1 C++11 Standard 常见疑问\t8\n2.1.2 C++98 和 C++11 的兼容性\t9\n2.2 复杂度与 Big-O 标记\t10\n3 语言新特性\t13\n3.1 C++11 语言新特性\t13\n3.1.1 微小但重要的语法提升\t13\n3.1.2 以auto完成类型自动推导\t14\n3.1.3 一致性初始化（Uniform Initialization）与初值列（Initializer List）\t15\n3.1.4 Range-Based for循环\t17\n3.1.5 Move 语义和 Rvalue Reference\t19\n3.1.6 新式的字符串字面常量（String Literal）\t23\n3.1.7 关键字noexcept\t24\n3.1.8 关键字constexpr\t26\n3.1.9 崭新的 Template 特性\t26\n3.1.10 Lambda\t28\n3.1.11 关键字decltype\t32\n3.1.12 新的函数声明语法（New Function Declaration Syntax）\t32\n3.1.13 带领域的（Scoped） Enumeration\t32\n3.1.14 新的基础类型（New Fundamental Data Type）\t33\n3.2 虽旧犹新的语言特性\t33\n3.2.1 基础类型的明确初始化（Explicit Initialization for Fundamental Type）\t37\n3.2.2 main()定义式\t37\n4 一般概念\t39\n4.1 命名空间（Namespace）std\t39\n4.2 头文件（Header File）\t40\n4.3 差错和异常（Error and Exception）的处理\t41\n4.3.1 标准的 Exception Class（异常类）\t41\n4.3.2 异常类（Exception Class）的成员\t44\n4.3.3 以 Class exception_ptr传递异常\t52\n4.3.4 抛出标准异常\t53\n4.3.5 自标准异常类派生\t54\n4.4 Callable Object（可被调用的对象）\t54\n4.5 并发与多线程\t55\n4.6 分配器（Allocator）\t57\n5 通用工具\t59\n5.1 Pair 和 Tuple\t60\n5.1.1 Pair\t60\n5.1.2 Tuple（不定数的值组）\t68\n5.1.3 Tuple 的输入\/输出\t74\n5.1.4 tuple和pair转换\t75\n5.2 Smart Pointer（智能指针）\t76\n5.2.1 Class shared_ptr\t76\n5.2.2 Class weak_ptr\t84\n5.2.3 误用 Shared Pointer\t89\n5.2.4 细究 Shared Pointer 和 Weak Pointer\t92\n5.2.5 Class unique_ptr\t98\n5.2.6 细究 Class unique_ptr\t110\n5.2.7 Class auto_ptr\t113\n5.2.8 Smart Pointer 结语\t114\n5.3 数值的极值（Numeric Limit）\t115\n5.4 Type Trait 和 Type Utility\t122\n5.4.1 Type Trait 的目的\t122\n5.4.2 细究 Type Trait\t125\n5.4.3 Reference Wrapper（外覆器）\t132\n5.4.4 Function Type Wrapper（外覆器）\t133\n5.5 辅助函数\t134\n5.5.1 挑选最小值和最大值\t134\n5.5.2 两值互换（Swapping）\t136\n5.5.3 增补的“比较操作符”（Comparison Operator）\t138\n5.6 Class ratio<>的编译期分数运算\t140\n5.7 Clock 和 Timer\t143\n5.7.1 Chrono 程序库概观\t143\n5.7.2 Duration（时间段）\t144\n5.7.3 Clock（时钟）和 Timepoint（时间点）\t149\n5.7.4 C 和 POSIX 提供的 Date\/Time 函数\t157\n5.7.5 以计时器停滞线程（Blocking with Timer）\t160\n5.8 头文件<cstddef>、<cstdlib>和<cstring>\t161\n5.8.1 <cstddef>内的各项定义\t161\n5.8.2 <cstdlib>内的各种定义\t162\n5.8.3 <cstring>中的定义式\t163\n6 标准模板库\t165\n6.1 STL 组件（Component）\t165\n6.2 容器（Container）\t167\n6.2.1 序列式容器（Sequence Container）\t169\n6.2.2 关联式容器（Associative Container）\t177\n6.2.3 无序容器（Unordered Container）\t180\n6.2.4 关联式数组（Associative Array）\t185\n6.2.5 其他容器\t187\n6.2.6 容器适配器（Container Adapter）\t188\n6.3 迭代器（Iterator）\t188\n6.3.1 关联式（ Associative ）及无序（ Unordered ）容器的更多实例\t193\n6.3.2 迭代器种类（Iterator Category）\t198\n6.4 算法（Algorithm）\t199\n6.4.1 区间（Range）\t203\n6.4.2 处理多重区间（Multiple Ranges）\t207\n6.5 迭代器之适配器（Iterator Adapter）\t210\n6.5.1 Insert Iterator（安插型迭代器）\t210\n6.5.2 Stream Iterator（串流迭代器）\t212\n6.5.3 Reverse Iterator（反向迭代器）\t214\n6.5.4 Move Iterator（搬移迭代器）\t216\n6.6 用户自定义的泛型函数（User-Defined Generic Function）\t216\n6.7 更易型算法（Manipulating Algorithm）\t217\n6.7.1 移除（Removing）元素\t218\n6.7.2 更易 Associative（关联式）和 Unordered（无序）容器\t221\n6.7.3 算法 vs. 成员函数\t223\n6.8 以函数作为算法的实参\t224\n6.8.1 以函数作为算法实参的实例示范\t224\n6.8.2 判断式（Predicate）\t226\n6.9 使用 Lambda\t229\n6.10 函数对象（Function Object）\t233\n6.10.1 定义一个函数对象\t233\n6.10.2 预定义的函数对象\t239\n6.10.3 Binder\t241\n6.10.4 函数对象 vs. Lambda\t243\n6.11 容器内的元素\t244\n6.11.1 容器元素的必要条件\t244\n6.11.2 Value 语义 vs. Reference 语义\t245\n6.12 STL 内部的错误和异常\t245\n6.12.1 错误处理（Error Handling）\t246\n6.12.2 异常处理（Exception Handling）\t248\n6.13 扩展 STL\t250\n6.13.1 整合更多 Type\t250\n6.13.2 派生自 STL Type\t251\n7 STL 容器\t253\n7.1 容器的共通能力和共通操作\t254\n7.1.1 容器的共通能力\t254\n7.1.2 容器的共通操作\t254\n7.1.3 容器提供的类型\t260\n7.2 Array\t261\n7.2.1 Array 的能力\t261\n7.2.2 Array 的操作\t263\n7.2.3 把array当成 C-Style Array\t267\n7.2.4 异常处理（ Exception Handling ）\t268\n7.2.5 Tuple 接口\t268\n7.2.6 Array 运用实例\t268\n7.3 Vector\t270\n7.3.1 Vector 的能力\t270\n7.3.2 Vector 的操作\t273\n7.3.3 将 Vector 当作 C-Style Array 使用\t278\n7.3.4 异常处理（ Exception Handling ）\t278\n7.3.5 Vector 使用实例\t279\n7.3.6 Class vector<bool>\t281\n7.4 Deque\t283\n7.4.1 Deque 的能力\t284\n7.4.2 Deque 的操作函数\t284\n7.4.3 Exception Handling\t288\n7.4.4 Deque 运用实例\t288\n7.5 List\t290\n7.5.1 List 的能力\t290\n7.5.2 List 的操作\t291\n7.5.3 异常处理（ Exception Handling ）\t296\n7.5.4 List 运用实例\t298\n7.6 Forward List\t300\n7.6.1 Forward List 的能力\t300\n7.6.2 Forward List 的操作\t302\n7.6.3 异常处理（ Exception Handling ）\t311\n7.6.4 Forward List 运用实例\t312\n7.7 Set 和 Multiset\t314\n7.7.1 Set 和 Multiset 的能力\t315\n7.7.2 Set and Multiset 的操作函数\t316\n7.7.3 异常处理（ Exception Handling ）\t325\n7.7.4 Set 和 Multiset 运用实例\t325\n7.7.5 运行期指定排序准则\t328\n7.8 Map 和 Multimap\t331\n7.8.1 Map 和 Multimap 的能力\t332\n7.8.2 Map 和 Multimap 的操作函数\t333\n7.8.3 将 Map 视为关联式数组（ Associative Array ）\t343\n7.8.4 异常处理（ Exception Handling ）\t345\n7.8.5 Map 和 Multimap 运用实例\t345\n7.8.6 综合实例：运用 Map、 String 并于运行期指定排序准则\t351\n7.9 无序容器（ Unordered Container ）\t355\n7.9.1 Unordered 容器的能力\t357\n7.9.2 创建和控制 Unordered 容器\t359\n7.9.3 Unordered 容器的其他操作\t367\n7.9.4 Bucket 接口\t374\n7.9.5 使用 Unordered Map 作为 Associative Array\t374\n7.9.6 异常处理（ Exception Handling ）\t375\n7.9.7 Unordered 容器的运用实例\t375\n7.10 其他 STL 容器\t385\n7.10.1 String 作为一种 STL 容器\t385\n7.10.2 C-Style Array 作为一种 STL 容器\t386\n7.11 实现 Reference 语义\t388\n7.12 各种容器的使用时机\t392\n8 细探 STL 容器成员\t397\n8.1 容器内的类型\t397\n8.2 创建、复制和销毁（ Create, Copy, and Destroy ）\t400\n8.3 非更易型操作（ Nonmodifying Operation ）\t403\n8.3.1 大小相关操作（ Size Operation ）\t403\n8.3.2 元素比较（ Comparison Operation ）\t404\n8.3.3 Associative 和 Unordered 容器特有的非更易型操作\t404\n8.4 赋值（ Assignment ）\t406\n8.5 元素直接访问（ Direct Element Access ）\t408\n8.6 “产出迭代器”之各项操作\t410\n8.7 安插和移除（ Inserting and Removing ）元素\t411\n8.7.1 安插单一元素（ Inserting Single Element ）\t411\n8.7.2 安插多重元素（ Inserting Multiple Elements ）\t416\n8.7.3 移除元素（ Removing Element ）\t417\n8.7.4 重设大小（ Resizing ）\t420\n8.8 List 和 Forward List 的特殊成员函数\t420\n8.8.1 特殊成员函数（针对 List 和 Forward List ）\t420\n8.8.2 特殊成员函数（只针对 Forward List ）\t423\n8.9 容器的策略接口（ Policy Interface ）\t427\n8.9.1 非更易型策略函数（ Nonmodifying Policy Function ）\t427\n8.9.2 更易型策略函数（ Modifying Policy Function ）\t428\n8.9.3 Unordered 容器的 Bucket 相关接口\t429\n8.10 对分配器（ Allocator ）的支持\t430\n8.10.1 基本的分配器成员（ Fundamental Allocator Member ）\t430\n8.10.2 带有“可选之分配器参数”的构造函数\t430\n9 STL 迭代器\t433\n9.1 迭代器头文件（ Header Files for Iterators ）\t433\n9.2 迭代器种类（ Iterator Category ）\t433\n9.2.1 Output 迭代器\t433\n9.2.2 Input 迭代器\t435\n9.2.3 Forward（前向）迭代器\t436\n9.2.4 Bidirectional（双向）迭代器\t437\n9.2.5 Random-Access（随机访问）迭代器\t438\n9.2.6 Vector 迭代器的递增（ Increment ）和递减（ Decrement ）\t440\n9.3 迭代器相关辅助函数\t441\n9.3.1 advance()\t441\n9.3.2 next()和prev()\t443\n9.3.3 distance()\t445\n9.3.4 iter_swap()\t446\n9.4 迭代器适配器（ Iterator Adapter ）\t448\n9.4.1 Reverse（反向）迭代器\t448\n9.4.2 Insert（安插型）迭代器\t454\n9.4.3 Stream（串流）迭代器\t460\n9.4.4 Move（搬移）迭代器\t466\n9.5 Iterator Trait（迭代器特性）\t466\n9.5.1 为迭代器编写泛型函数（ Generic Function ）\t468\n9.6 用户自定义（ User-Defined ）迭代器\t471\n10 STL 函数对象及 Lambda\t475\n10.1 Function Object（函数对象）的概念\t475\n10.1.1 以 Function Object 为排序准则（ Sorting Criterion ）\t476\n10.1.2 Function Object 拥有内部状态（ Internal State ）\t478\n10.1.3 for_each()的返回值\t482\n10.1.4 Predicate（判断式） vs. Function Object（函数对象）\t483\n10.2 预定义的 Function Object 和 Binder\t486\n10.2.1 预定义的 Function Object\t486\n10.2.2 Function Adapter 和 Binder\t487\n10.2.3 以 Function Adapter 搭配用户自定义的 Function Object\t495\n10.2.4 过时的（ Deprecated ） Function Adapter\t497\n10.3 运用 Lambda\t499\n10.3.1 Lambda vs. Binder\t499\n10.3.2 Lambda vs. 带有状态的（ Stateful ） Function Object\t500\n10.3.3 Lambda 调用全局函数和成员函数\t502\n10.3.4 Lambda 作为 Hash 函数、排序准则或相等准则\t504\n11 STL 算法\t505\n11.1 算法头文件（Header File）\t505\n11.2 算法概观\t505\n11.2.1 扼要介绍\t506\n11.2.2 算法分门别类\t506\n11.3 辅助函数\t517\n11.4 for_each()算法\t519\n11.5 非更易型算法（Nonmodifying Algorithm）\t524\n11.5.1 元素计数\t524\n11.5.2 最小值和最大值\t525\n11.5.3 查找元素（Searching Element）\t528\n11.5.4 区间的比较\t542\n11.5.5 Predicate 用以检验区间\t550\n11.6 更易型算法（Modifying Algorithm）\t557\n11.6.1 复制元素（Copying Element）\t557\n11.6.2 搬移元素（Moving Element）\t561\n11.6.3 转换和结合元素（Transforming and Combining Element）\t563\n11.6.4 互换元素（Swapping Elements）\t566\n11.6.5 赋值（Assigning New Value）\t568\n11.6.6 替换元素（Replacing Element）\t571\n11.7 移除型算法（Removing Algorithm）\t575\n11.7.1 移除某些元素\t575\n11.7.2 移除重复元素\t578\n11.8 变序型算法（Mutating Algorithm）\t583\n11.8.1 反转元素次序（Reversing the Order of Elements）\t583\n11.8.2 旋转元素（Rotating Elements）\t584\n11.8.3 排列元素（Permuting Elements）\t587\n11.8.4 对元素重新洗牌（Shuffling Elements）\t589\n11.8.5 将元素向前搬（Moving Elements to the Front）\t592\n11.8.6 划分为两个子区间（Partition into Two Subranges）\t594\n11.9 排序算法（Sorting Algorithm）\t596\n11.9.1 对所有元素排序\t596\n11.9.2 局部排序（Partial Sorting）\t599\n11.9.3 根据第 {\\itshape n} 个元素排序\t602\n11.9.4 Heap 算法\t604\n11.10 已序区间算法（Sorted-Range Algorithm）\t608\n11.10.1 查找元素（Searching Element）\t608\n11.10.2 合并元素（Merging Elements）\t614\n11.11 数值算法（Numeric Algorithm）\t623\n11.11.1 运算后产生结果\t623\n11.11.2 相对数列和绝对数列之间的转换\t627\n12 特殊容器\t631\n12.1 Stack（堆栈）\t632\n12.1.1 核心接口\t633\n12.1.2 Stack 运用实例\t633\n12.1.3 一个用户自定义的 Stack Class\t635\n12.1.4 细究 Class stack<>\t637\n12.2 Queue（队列）\t638\n12.2.1 核心接口\t639\n12.2.2 Queue 运用实例\t640\n12.2.3 一个用户自定义的 Queue Class\t641\n12.2.4 细究 Class queue<>\t641\n12.3 Priority Queue（带优先级的队列）\t641\n12.3.1 核心接口\t643\n12.3.2 Priority Queue 运用实例\t643\n12.3.3 细究 Class priority_queue<>\t644\n12.4 细究 Container Adapter\t645\n12.4.1 类型定义\t645\n12.4.2 构造函数（Constructor）\t646\n12.4.3 Priority Queue 额外提供的构造函数\t646\n12.4.4 各项操作（Operation）\t647\n12.5 Bitset\t650\n12.5.1 Bitset 运用实例\t651\n12.5.2 细究 Class bitset\t653\n13 字符串\t655\n13.1 String Class 的目的\t656\n13.1.1 例一：提炼临时文件名\t656\n13.1.2 例二：提炼单词并反向打印\t660\n13.2 String Class 细节描述\t663\n13.2.1 String 的各种相关类型\t663\n13.2.2 操作函数概览\t666\n13.2.3 构造函数和析构函数（Constructor and Destructor）\t667\n13.2.4 String 和 C-String\t668\n13.2.5 大小和容量（Size and Capacity）\t669\n13.2.6 元素访问（Element Access）\t671\n13.2.7 比较（Comparison）\t672\n13.2.8 更改内容（Modifier）\t673\n13.2.9 子字符串（Substring）及字符串接合（String Concatenation）\t676\n13.2.10 I\/O 操作符\t677\n13.2.11 搜索和查找（Searching and Finding）\t678\n13.2.12 npos的意义\t680\n13.2.13 数值转换（Numeric Conversion）\t681\n13.2.14 String 对迭代器的支持\t684\n13.2.15 国际化（Internationalization）\t689\n13.2.16 效率（Performance）\t692\n13.2.17 String 和 Vector\t692\n13.3 细究 String Class\t693\n13.3.1 类型定义和静态值\t693\n13.3.2 创建、复制、销毁（Create, Copy, and Destroy）\t694\n13.3.3 大小和容量（Size and Capacity）\t696\n13.3.4 比较（Comparison）\t697\n13.3.5 字符访问\t699\n13.3.6 产生 C-String 和字符数组（Character Array）\t700\n13.3.7 “改动”之相关操作（Modifying Operation）\t700\n13.3.8 查找（Searching and Finding）\t708\n13.3.9 子字符串（Substring）及字符串接合（String Concatenation）\t711\n13.3.10 I\/O函数\t712\n13.3.11 数值转换（Numeric Conversion）\t713\n13.3.12 生成 Iterator\t714\n13.3.13 对 Allocator 的支持\t715\n14 正则表达式\t717\n14.1 Regex 的匹配和查找接口（Match and Search Interface）\t717\n14.2 处理“次表达式”（Subexpression）\t720\n14.3 Regex Iterator\t726\n14.4 Regex Token Iterator\t727\n14.5 用于替换的正则表达式\t730\n14.6 Regex Flag\t732\n14.7 Regex 的异常（Exception）\t735\n14.8 Regex ECMAScript 文法\t738\n14.9 其他文法\t739\n14.10 细究 Basic Regex 签名式\t740\n15 以 Stream 完成 I\/O\t743\n15.1 I\/O Stream 的共通基础（Common Background）\t744\n15.1.1 Stream 对象\t744\n15.1.2 Stream Class\t744\n15.1.3 全局的 Stream 对象\t745\n15.1.4 Stream 操作符\t745\n15.1.5 操控器（Manipulator）\t746\n15.1.6 一个简单例子\t746\n15.2 基本 Stream Class 和其对象\t748\n15.2.1 Class 及其层次体系\t748\n15.2.2 全局性的 Stream 对象\t751\n15.2.3 头文件\t752\n15.3 标准的 Stream 操作符<<和>>\t753\n15.3.1 Output 操作符<<\t753\n15.3.2 Input 操作符>>\t754\n15.3.3 特殊类型的 I\/O\t755\n15.4 Stream 的状态（State）\t758\n15.4.1 表示“ Stream 状态”的常量\t758\n15.4.2 用来“处理 Stream 状态”的成员函数\t759\n15.4.3 Stream 状态与 Boolean 条件测试\t760\n15.4.4 Stream 的状态和异常\t762\n15.5 标准 I\/O 函数\t767\n15.5.1 Input 相关函数\t768\n15.5.2 Output 相关函数\t771\n15.5.3 实例\t772\n15.5.4 sentry对象\t772\n15.6 操控器（Manipulator）\t774\n15.6.1 操控器概览\t774\n15.6.2 操控器如何运作\t776\n15.6.3 用户自定义的操控器\t777\n15.7 格式化（Formatting）\t779\n15.7.1 Format Flag（格式标志）\t779\n15.7.2 Boolean 的 I\/O 格式\t781\n15.7.3 栏位宽度、填充字符、位置调整\t781\n15.7.4 正号与大写\t784\n15.7.5 数值基底（Numeric Base）\t785\n15.7.6 浮点数（Floating-Point）表示法\t787\n15.7.7 一般格式（General Formatting）定义\t789\n15.8 国际化（Internationalization）\t790\n15.9 文件访问（File Access）\t791\n15.9.1 File Stream Class\t791\n15.9.2 File Stream 的 Rvalue 和 Move 语义\t795\n15.9.3 File Flag（文件标志）\t796\n15.9.4 随机访问（Random Access）\t799\n15.9.5 使用文件描述器（File Descriptor）\t801\n15.10 为 String 而设计的 Stream Class\t802\n15.10.1 String Stream Class\t802\n15.10.2 String Stream 的 Move 语义\t806\n15.10.3 char* Stream Class\t807\n15.11 “用户自定义类型”之 I\/O 操作符\t810\n15.11.1 实现一个 Output 操作符\t810\n15.11.2 实现一个 Input 操作符\t812\n15.11.3 以辅助函数完成 I\/O\t814\n15.11.4 用户自定义之 Format Flag（格式标志）\t815\n15.11.5 用户自定义 I\/O 操作符的规约（Convention）\t818\n15.12 连接 Input 和 Output Stream\t819\n15.12.1 以tie()完成松耦合（Loose Coupling）\t819\n15.12.2 以 Stream 缓冲区完成紧耦合（Tight Coupling）\t820\n15.12.3 将标准 Stream 重定向（Redirecting）\t822\n15.12.4 可读可写的 Stream\t824\n15.13 Stream Buffer Class\t826\n15.13.1 Stream 缓冲区接口\t826\n15.13.2 Stream 缓冲区的 Iterator\t828\n15.13.3 用户自定义之 Stream 缓冲区\t832\n15.14 关于效能（Performance）\t844\n15.14.1 与 C 标准串流同步（Synchronization with C's Standard Streams）\t845\n15.14.2 Stream 缓冲区内的缓冲机制\t845\n15.14.3 直接使用 Stream 缓冲区\t846\n16 国际化\t849\n16.1 字符编码和字符集\t850\n16.1.1 多字节（Multibyte）和宽字符（Wide-Character）文本\t850\n16.1.2 不同的字符集\t851\n16.1.3 在 C++ 中处理字符集\t852\n16.1.4 Character Trait\t853\n16.1.5 特殊字符的国际化\t857\n16.2 Locale（地域）概念\t857\n16.2.1 使用 Locale\t858\n16.2.2 Locale Facet\t864\n16.3 细究 Locale\t866\n16.4 细究 Facet\t869\n16.4.1 数值格式化（Numeric Formatting）\t870\n16.4.2 货币符号格式化（Monetary Formatting）\t874\n16.4.3 时间和日期格式化（Time and Date Formatting）\t884\n16.4.4 字符的分类和转换\t891\n16.4.5 字符串校勘（String Collation）\t904\n16.4.6 消息国际化（Internationalized Message）\t905\n17 数值\t907\n17.1 随机数及分布（Random Number and Distribution）\t907\n17.1.1 第一个例子\t908\n17.1.2 引擎（Engine）\t912\n17.1.3 细说引擎（Engine）\t915\n17.1.4 分布（Distribution）\t917\n17.1.5 细说分布（Distribution）\t921\n17.2 复数（Complex Number）\t925\n17.2.1 Class complex<>一般性质\t925\n17.2.2 Class complex<>运用实例\t926\n17.2.3 复数的各项操作\t928\n17.2.4 细说 Class complex<>\t935\n17.3 全局数值函数（Global Numeric Function）\t941\n17.4 Valarray\t943\n18 并发\t945\n18.1 高级接口：async()和 Future\t946\n18.1.1 async()和 Future 的第一个用例\t946\n18.1.2 实例：等待两个 Task\t955\n18.1.3 Shared Future\t960\n18.2 低层接口：Thread 和 Promise\t964\n18.2.1 Class std::thread\t964\n18.2.2 Promise\t969\n18.2.3 Class packaged_task<>\t972\n18.3 细说启动线程（Starting a Thread）\t973\n18.3.1 细说async()\t974\n18.3.2 细说 Future\t975\n18.3.3 细说 Shared Future\t976\n18.3.4 细说 Class std::promise\t977\n18.3.5 细说 Class std::packaged_task\t977\n18.3.6 细说 Class std::thread\t979\n18.3.7 Namespace this_thread\t981\n18.4 线程同步化与 Concurrency（并发）问题\t982\n18.4.1 当心 Concurrency（并发）\t982\n18.4.2 Concurrent Data Access 为什么造成问题\t983\n18.4.3 什么情况下可能出错\t983\n18.4.4 解决问题所需要的性质（Feature）\t987\n18.5 Mutex 和 Lock\t989\n18.5.1 使用 Mutex 和 Lock\t989\n18.5.2 细说 Mutex 和 Lock\t998\n18.5.3 只调用一次\t1000\n18.6 Condition Variable（条件变量）\t1003\n18.6.1 Condition Variable（条件变量）的意图\t1003\n18.6.2 Condition Variable（条件变量）的第一个完整例子\t1004\n18.6.3 使用 Condition Variable（条件变量）实现多线程 Queue\t1006\n18.6.4 细说 Condition Variable（条件变量）\t1009\n18.7 Atomic\t1012\n18.7.1 Atomic 用例\t1012\n18.7.2 细说 Atomic 及其高级接口\t1016\n18.7.3 Atomic 的 C-Style 接口\t1019\n18.7.4 Atomic 的低层接口\t1019\n19 分配器\t1023\n19.1 以应用程序开发者的角度使用 Allocator\t1023\n19.2 用户自定义的 Allocator\t1024\n19.3 以程序库开发者的角度使用 Allocator\t1026\n参考书目\t1031\n新闻组及论坛（ Newsgroup and Forum ）\t1031\n书籍和网站\t1032\n索引\t1037","pages":"1128","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28104600.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28104600.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28104600.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26419721\/","id":"26419721","publisher":"电子工业出版社","isbn10":"7121260891","isbn13":"9787121260896","title":"C++标准库（第2版）","url":"https:\/\/api.douban.com\/v2\/book\/26419721","alt_title":"The C++ Standard Library: A Tutorial and Reference","author_intro":"Nicolai M. Josuttis是一名独立技术顾问，为电信、交通、金融和制造业设计过大中型软件系统。他曾是C++标准委员会库工作小组成员，因其权威著作而在编程领域声名鹊起。除了最为畅销的《C++标准库》（第1版出版于1999年），其著作还包括C++ Templates: The Complete Guide（与David Vandevoorde合著，由Addison-Wesley于2003年出版），以及SOA in Practice: The Art of Distributed System Design（由O’Reilly Media于2007年出版，简体中文版《SOA实践指南——分布式系统设计的艺术》由电子工业出版社于2008年出版）。\n译者侯捷：计算机技术书籍的作家、译者、书评人，长期活跃于C++技术分享与教学领域。著有《深入浅出MFC》《多型与虚拟》《STL源码剖析》《无责任书评》三卷，译有众多脍炙人口的权威技术书籍，包括Meyers所著的“Effective C++”系列。侯捷兼任教职于元智大学、同济大学、南京大学。","summary":"《C++标准库（第2版）》是全球C++经典权威参考书籍时隔12年，基于C++11标准的全新重大升级。标准库提供了一组公共类和接口，极大地拓展了C++语言核心功能。《C++标准库（第2版）》详细讲解了每一标准库组件，包括其设计目的和方法、复杂概念的剖析、实用而高效的编程细节、存在的陷阱、重要的类和函数，又辅以大量用C++11标准实现的实用代码范例。除覆盖全新组件、特性外，《C++标准库（第2版）》一如前版，重点着眼于标准模板库（STL），涉及容器、迭代器、函数对象以及STL算法。此外，《C++标准库（第2版）》同样关注lambda表达式、基于区间的for循环、move语义及可变参数模板等标准库中的新式C++编程风格及其影响。","price":"186.00元"}