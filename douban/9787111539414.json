{"rating":{"max":10,"numRaters":34,"average":"9.6","min":0},"subtitle":"","author":["Bjarne Stroustrup"],"pubdate":"2016-7","tags":[{"count":51,"name":"C++","title":"C++"},{"count":13,"name":"计算机","title":"计算机"},{"count":13,"name":"程序设计","title":"程序设计"},{"count":9,"name":"C++11","title":"C++11"},{"count":8,"name":"C\/C++","title":"C\/C++"},{"count":6,"name":"C","title":"C"},{"count":6,"name":"11","title":"11"},{"count":5,"name":"计算机科学","title":"计算机科学"}],"origin_title":"The C++ Programming Language, Fourth Edition","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28984939.jpg","binding":"平装","translator":["王刚","杨巨峰"],"catalog":"出版者的话\n译者序\n前言\n第3版前言\n第2版前言\n第1版前言\n第一部分　引言\n第1章　致读者 2\n1.1　本书结构 2\n1.1.1　引言 2\n1.1.2　基本特性 3\n1.1.3　抽象机制 4\n1.1.4　标准库 5\n1.1.5　例子和参考文献 5\n1.2　C++的设计 7\n1.2.1　程序设计风格 8\n1.2.2　类型检查 11\n1.2.3　C兼容性 12\n1.2.4　语言、库和系统 12\n1.3　学习C++ 14\n1.3.1　用C++编程 15\n1.3.2　对C++程序员的建议 16\n1.3.3　对C程序员的建议 16\n1.3.4　对Java程序员的建议 17\n1.4　C++的历史 18\n1.4.1　大事年表 19\n1.4.2　早期的C++ 19\n1.4.3　1998标准 21\n1.4.4　2011标准 23\n1.4.5　C++的用途 26\n1.5　建议 27\n1.6　参考文献 28\n第2章　C++概览：基础知识 32\n2.1　引言 32\n2.2　基本概念 33\n2.2.1　Hello，World! 33\n2.2.2　类型、变量和算术运算 34\n2.2.3　常量 36\n2.2.4　检验和循环 37\n2.2.5　指针、数组和循环 38\n2.3　用户自定义类型 40\n2.3.1　结构 41\n2.3.2　类 42\n2.3.3　枚举 43\n2.4　模块化 44\n2.4.1　分离编译 45\n2.4.2　名字空间 46\n2.4.3　错误处理 47\n2.5　附记 50\n2.6　建议 50\n第3章　C++概览：抽象机制 51\n3.1　引言 51\n3.2　类 51\n3.2.1　具体类型 52\n3.2.2　抽象类型 56\n3.2.3　虚函数 58\n3.2.4　类层次 59\n3.3　拷贝和移动 62\n3.3.1　拷贝容器 63\n3.3.2　移动容器 64\n3.3.3　资源管理 66\n3.3.4　抑制操作 66\n3.4　模板 67\n3.4.1　参数化类型 67\n3.4.2　函数模板 69\n3.4.3　函数对象 69\n3.4.4　可变参数模板 71\n3.4.5　别名 72\n3.5　建议 73\n第4章　C++概览：容器与算法 74\n4.1　标准库 74\n4.1.1　标准库概述 75\n4.1.2　标准库头文件与名字空间 75\n4.2　字符串 77\n4.3　I\/O流 78\n4.3.1　输出 78\n4.3.2　输入 79\n4.3.3　用户自定义类型的I\/O 80\n4.4　容器 81\n4.4.1　vector 81\n4.4.2　list 84\n4.4.3　map 85\n4.4.4　unordered_map 86\n4.4.5　容器概述 86\n4.5　算法 87\n4.5.1　使用迭代器 88\n4.5.2　迭代器类型 90\n4.5.3　流迭代器 91\n4.5.4　谓词 93\n4.5.5　算法概述 93\n4.5.6　容器算法 94\n4.6　建议 94\n第5章　C++概览：并发与实用功能 96\n5.1　引言 96\n5.2　资源管理 96\n5.2.1　unique_ptr与shared_ptr 97\n5.3　并发 99\n5.3.1　任务和thread 99\n5.3.2　传递参数 100\n5.3.3　返回结果 100\n5.3.4　共享数据 101\n5.3.5　任务通信 103\n5.4　小工具组件 106\n5.4.1　时间 106\n5.4.2　类型函数 107\n5.4.3　pair和tuple 109\n5.5　正则表达式 110\n5.6　数学计算 111\n5.6.1　数学函数和算法 111\n5.6.2　复数 111\n5.6.3　随机数 112\n5.6.4　向量算术 113\n5.6.5　数值限制 113\n5.7　建议 114\n第二部分　基本功能\n第6章　类型与声明 116\n6.1　ISO C++标准 116\n6.1.1　实现 117\n6.1.2　基本源程序字符集 118\n6.2　类型 118\n6.2.1　基本类型 119\n6.2.2　布尔值 119\n6.2.3　字符类型 121\n6.2.4　整数类型 124\n6.2.5　浮点数类型 126\n6.2.6　前缀和后缀 127\n6.2.7　void 128\n6.2.8　类型尺寸 128\n6.2.9　对齐 130\n6.3　声明 131\n6.3.1　声明的结构 133\n6.3.2　声明多个名字 134\n6.3.3　名字 134\n6.3.4　作用域 136\n6.3.5　初始化 138\n6.3.6　推断类型：auto和decltype() 141\n6.4　对象和值 144\n6.4.1　左值和右值 144\n6.4.2　对象的生命周期 145\n6.5　类型别名 146\n6.6　建议 147\n第7章　指针、数组与引用 148\n7.1　引言 148\n7.2　指针 148\n7.2.1　void* 149\n7.2.2　nullptr 150\n7.3　数组 150\n7.3.1　数组的初始化器 152\n7.3.2　字符串字面值常量 152\n7.4　数组中的指针 155\n7.4.1　数组漫游 156\n7.4.2　多维数组 158\n7.4.3　传递数组 159\n7.5　指针与const 161\n7.6　指针与所有权 163\n7.7　引用 163\n7.7.1　左值引用 164\n7.7.2　右值引用 167\n7.7.3　引用的引用 169\n7.7.4　指针与引用 170\n7.8　建议 172\n第8章　结构、联合与枚举 173\n8.1　引言 173\n8.2　结构 173\n8.2.1　struct的布局 175\n8.2.2　struct的名字 176\n8.2.3　结构与类 177\n8.2.4　结构与数组 178\n8.2.5　类型等价 180\n8.2.6　普通旧数据 180\n8.2.7　域 182\n8.3　联合 183\n8.3.1　联合与类 185\n8.3.2　匿名 186\n8.4　枚举 188\n8.4.1　enum class 188\n8.4.2　普通的enum 191\n8.4.3　未命名的enum 192\n8.5　建议 193\n第9章　语句 194\n9.1　引言 194\n9.2　语句概述 194\n9.3　声明作为语句 195\n9.4　选择语句 196\n9.4.1　if语句 196\n9.4.2　switch语句 198\n9.4.3　条件中的声明 200\n9.5　循环语句 201\n9.5.1　范围for语句 201\n9.5.2　for语句 202\n9.5.3　while语句 203\n9.5.4　do语句 203\n9.5.5　退出循环 204\n9.6　goto语句 204\n9.7　注释与缩进 205\n9.8　建议 207\n第10章　表达式 208\n10.1　引言 208\n10.2　一个桌面计算器示例 208\n10.2.1　分析器 209\n10.2.2　输入 213\n10.2.3　底层输入 216\n10.2.4　错误处理 217\n10.2.5　驱动程序 217\n10.2.6　头文件 218\n10.2.7　命令行参数 218\n10.2.8　关于风格 220\n10.3　运算符概述 220\n10.3.1　结果 224\n10.3.2　求值顺序 224\n10.3.3　运算符优先级 225\n10.3.4　临时对象 226\n10.4　常量表达式 227\n10.4.1　符号化常量 229\n10.4.2　常量表达式中的const 229\n10.4.3　字面值常量类型 229\n10.4.4　引用参数 230\n10.4.5　地址常量表达式 231\n10.5　隐式类型转换 231\n10.5.1　提升 231\n10.5.2　类型转换 232\n10.5.3　常用的算术类型转换 234\n10.6　建议 235\n第11章　选择适当的操作 236\n11.1　其他运算符 236\n11.1.1　逻辑运算符 236\n11.1.2　位逻辑运算符 236\n11.1.3　条件表达式 238\n11.1.4　递增与递减 238\n11.2　自由存储 240\n11.2.1　内存管理 241\n11.2.2　数组 243\n11.2.3　获取内存空间 244\n11.2.4　重载new 245\n11.3　列表 247\n11.3.1　实现模型 248\n11.3.2　限定列表 249\n11.3.3　未限定列表 249\n11.4　lambda表达式 251\n11.4.1　实现模型 251\n11.4.2　lambda的替代品 252\n11.4.3　捕获 254\n11.4.4　调用与返回 257\n11.4.5　lambda的类型 257\n11.5　显式类型转换 258\n11.5.1　构造 259\n11.5.2　命名转换 261\n11.5.3　C风格的转换 262\n11.5.4　函数形式的转换 262\n11.6　建议 263\n第12章　函数 264\n12.1　函数声明 264\n12.1.1　为什么使用函数 265\n12.1.2　函数声明的组成要件 265\n12.1.3　函数定义 266\n12.1.4　返回值 267\n12.1.5　inline函数 269\n12.1.6　constexpr函数 269\n12.1.7　[[noreturn]]函数 271\n12.1.8　局部变量 272\n12.2　参数传递 273\n12.2.1　引用参数 273\n12.2.2　数组参数 275\n12.2.3　列表参数 277\n12.2.4　数量未定的参数 278\n12.2.5　默认参数 281\n12.3　重载函数 282\n12.3.1　自动重载解析 283\n12.3.2　重载与返回类型 284\n12.3.3　重载与作用域 285\n12.3.4　多实参解析 285\n12.3.5　手动重载解析 286\n12.4　前置与后置条件 286\n12.5　函数指针 288\n12.6　宏 292\n12.6.1　条件编译 294\n12.6.2　预定义宏 295\n12.6.3　编译指令 296\n12.7　建议 296\n第13章　异常处理 297\n13.1　错误处理 297\n13.1.1　异常 298\n13.1.2　传统的错误处理 299\n13.1.3　渐进决策 300\n13.1.4　另一种视角看异常 301\n13.1.5　何时不应使用异常 302\n13.1.6　层次化错误处理 303\n13.1.7　异常与效率 304\n13.2　异常保障 305\n13.3　资源管理 307\n13.3.1　finally 310\n13.4　强制不变式 311\n13.5　抛出与捕获异常 315\n13.5.1　抛出异常 315\n13.5.2　捕获异常 318\n13.5.3　异常与线程 324\n13.6　vector的实现 324\n13.6.1　一个简单的vector 325\n13.6.2　显式地表示内存 328\n13.6.3　赋值 331\n13.6.4　改变尺寸 332\n13.7　建议 335\n第14章　名字空间 337\n14.1　组合问题 337\n14.2　名字空间 338\n14.2.1　显式限定 339\n14.2.2　using声明 340\n14.2.3　using指示 341\n14.2.4　参数依赖查找 342\n14.2.5　名字空间是开放的 344\n14.3　模块化和接口 345\n14.3.1　名字空间作为模块 346\n14.3.2　实现 348\n14.3.3　接口和名字 349\n14.4　组合使用名字空间 351\n14.4.1　便利性与安全性 351\n14.4.2　名字空间别名 352\n14.4.3　组合名字空间 352\n14.4.4　组合与选择 353\n14.4.5　名字空间和重载 354\n14.4.6　版本控制 356\n14.4.7　名字空间嵌套 358\n14.4.8　无名名字空间 359\n14.4.9　C头文件 359\n14.5　建议 360\n第15章　源文件与程序 362\n15.1　分离编译 362\n15.2　链接 363\n15.2.1　文件内名字 365\n15.2.2　头文件 366\n15.2.3　单一定义规则 368\n15.2.4　标准库头文件 369\n15.2.5　链接非C++代码 370\n15.2.6　链接和函数指针 372\n15.3　使用头文件 373\n15.3.1　单头文件组织 373\n15.3.2　多头文件组织 376\n15.3.3　包含保护 380\n15.4　程序 381\n15.4.1　非局部变量初始化 381\n15.4.2　初始化和并发 382\n15.4.3　程序终止 383\n15.5　建议 384\n第三部分　抽象机制\n第16章　类 386\n16.1　引言 386\n16.2　类基础 387\n16.2.1　成员函数 388\n16.2.2　默认拷贝 389\n16.2.3　访问控制 389\n16.2.4　class和struct 390\n16.2.5　构造函数 391\n16.2.6　explicit构造函数 393\n16.2.7　类内初始化器 395\n16.2.8　类内函数定义 395\n16.2.9　可变性 396\n16.2.10　自引用 399\n16.2.11　成员访问 400\n16.2.12　static成员 401\n16.2.13　成员类型 403\n16.3　具体类 403\n16.3.1　成员函数 406\n16.3.2　辅助函数 408\n16.3.3　重载运算符 410\n16.3.4　具体类的重要性 410\n16.4　建议 411\n第17章　构造、清理、拷贝和移动 413\n17.1　引言 413\n17.2　构造函数和析构函数 415\n17.2.1　构造函数和不变式 415\n17.2.2　析构函数和资源 416\n17.2.3　基类和成员析构函数 417\n17.2.4　调用构造函数和析构函数 418\n17.2.5　virtual析构函数 419\n17.3　类对象初始化 420\n17.3.1　不使用构造函数进行初始化 420\n17.3.2　使用构造函数进行初始化 421\n17.3.3　默认构造函数 424\n17.3.4　初始化器列表构造函数 425\n17.4　成员和基类初始化 429\n17.4.1　成员初始化 429\n17.4.2　基类初始化器 431\n17.4.3　委托构造函数 431\n17.4.4　类内初始化器 432\n17.4.5　static成员初始化 434\n17.5　拷贝和移动 435\n17.5.1　拷贝 435\n17.5.2　移动 441\n17.6　生成默认操作 444\n17.6.1　显式声明默认操作 444\n17.6.2　默认操作 445\n17.6.3　使用默认操作 446\n17.6.4　使用delete删除的函数 449\n17.7　建议 451\n第18章　运算符重载 452\n18.1　引言 452\n18.2　运算符函数 453\n18.2.1　二元和一元运算符 454\n18.2.2　运算符的预置含义 455\n18.2.3　运算符与用户自定义类型 456\n18.2.4　传递对象 456\n18.2.5　名字空间中的运算符 457\n18.3　复数类型 459\n18.3.1　成员和非成员运算符 459\n18.3.2　混合模式运算 460\n18.3.3　类型转换 461\n18.3.4　字面值常量 463\n18.3.5　访问函数 464\n18.3.6　辅助函数 465\n18.4　类型转换 466\n18.4.1　类型转换运算符 466\n18.4.2　explicit类型转换运算符 467\n18.4.3　二义性 468\n18.5　建议 469\n第19章　特殊运算符 471\n19.1　引言 471\n19.2　特殊运算符 471\n19.2.1　取下标 471\n19.2.2　函数调用 472\n19.2.3　解引用 473\n19.2.4　递增和递减 475\n19.2.5　分配和释放 477\n19.2.6　用户自定义字面值常量 478\n19.3　字符串类 481\n19.3.1　必备操作 481\n19.3.2　访问字符 482\n19.3.3　类的表示 483\n19.3.4　成员函数 485\n19.3.5　辅助函数 487\n19.3.6　应用String 489\n19.4　友元 490\n19.4.1　发现友元 491\n19.4.2　友元与成员 492\n19.5　建议 493\n第20章　派生类 495\n20.1　引言 495\n20.2　派生类 496\n20.2.1　成员函数 498\n20.2.2　构造函数和析构函数 499\n20.3　类层次 500\n20.3.1　类型域 500\n20.3.2　虚函数 502\n20.3.3　显式限定 504\n20.3.4　覆盖控制 505\n20.3.5　using基类成员 508\n20.3.6　返回类型放松 511\n20.4　抽象类 512\n20.5　访问控制 514\n20.5.1　protected成员 517\n20.5.2　访问基类 518\n20.5.3　using声明与访问控制 519\n20.6　成员指针 520\n20.6.1　函数成员指针 520\n20.6.2　数据成员指针 522\n20.6.3　基类和派生类成员 523\n20.7　建议 523\n第21章　类层次 524\n21.1　引言 524\n21.2　设计类层次 524\n21.2.1　实现继承 525\n21.2.2　接口继承 527\n21.2.3　替代实现方式 529\n21.2.4　定位对象创建 532\n21.3　多重继承 533\n21.3.1　多重接口 533\n21.3.2　多重实现类 533\n21.3.3　二义性解析 535\n21.3.4　重复使用基类 538\n21.3.5　虚基类 539\n21.3.6　重复基类与虚基类 544\n21.4　建议 546\n第22章　运行时类型信息 547\n22.1　引言 547\n22.2　类层次导航 547\n22.2.1　dynamic_cast 548\n22.2.2　多重继承 551\n22.2.3　static_cast和dynamic_cast 552\n22.2.4　恢复接口 553\n22.3　双重分发和访客 557\n22.3.1　双重分发 557\n22.3.2　访客 559\n22.4　构造和析构 561\n22.5　类型识别 561\n22.5.1　扩展类型信息 563\n22.6　RTTI的使用和误用 564\n22.7　建议 565\n第23章　模板 566\n23.1　引言和概述 566\n23.2　一个简单的字符串模板 568\n23.2.1　定义模板 569\n23.2.2　模板实例化 571\n23.3　类型检查 571\n23.3.1　类型等价 572\n23.3.2　错误检测 573\n23.4　类模板成员 574\n23.4.1　数据成员 574\n23.4.2　成员函数 575\n23.4.3　成员类型别名 575\n23.4.4　static成员 575\n23.4.5　成员类型 576\n23.4.6　成员模板 577\n23.4.7　友元 580\n23.5　函数模板 582\n23.5.1　函数模板实参 583\n23.5.2　函数模板实参推断 584\n23.5.3　函数模板重载 586\n23.6　模板别名 590\n23.7　源码组织 591\n23.7.1　链接 593\n23.8　建议 594\n第24章　泛型程序设计 595\n24.1　引言 595\n24.2　算法和提升 596\n24.3　概念 599\n24.3.1　发现概念 599\n24.3.2　概念和约束 602\n24.4　具体化概念 604\n24.4.1　公理 607\n24.4.2　多实参概念 607\n24.4.3　值概念 608\n24.4.4　约束检查 609\n24.4.5　模板定义检查 610\n24.5　建议 612\n第25章　特例化 613\n25.1　引言 613\n25.2　模板参数和实参 614\n25.2.1　类型作为实参 614\n25.2.2　值作为实参 615\n25.2.3　操作作为实参 616\n25.2.4　模板作为实参 618\n25.2.5　默认模板实参 619\n25.3　特例化 621\n25.3.1　接口特例化 623\n25.3.2　主模板 624\n25.3.3　特例化顺序 625\n25.3.4　函数模板特例化 626\n25.4　建议 628\n第26章　实例化 629\n26.1　引言 629\n26.2　模板实例化 630\n26.2.1　何时需要实例化 630\n26.2.2　手工控制实例化 631\n26.3　名字绑定 632\n26.3.1　依赖性名字 633\n26.3.2　定义点绑定 635\n26.3.3　实例化点绑定 636\n26.3.4　多实例化点 638\n26.3.5　模板和名字空间 639\n26.3.6　过于激进的ADL 639\n26.3.7　来自基类的名字 641\n26.4　建议 643\n第27章　模板和类层次 645\n27.1　引言 645\n27.2　参数化和类层次 646\n27.2.1　生成类型 647\n27.2.2　模板类型转换 649\n27.3　类模板层次 650\n27.3.1　模板作为接口 651\n27.4　模板参数作为基类 652\n27.4.1　组合数据结构 652\n27.4.2　线性化类层次 655\n27.5　建议 660\n第28章　元编程 661\n28.1　引言 661\n28.2　类型函数 663\n28.2.1　类型别名 665\n28.2.2　类型谓词 666\n28.2.3　选择函数 668\n28.2.4　萃取 668\n28.3　控制结构 670\n28.3.1　选择 670\n28.3.2　迭代和递归 673\n28.3.3　何时使用元编程 674\n28.4　条件定义：Enable_if 675\n28.4.1　使用Enable_if 676\n28.4.2　实现Enable_if 678\n28.4.3　Enable_if与概念 678\n28.4.4　更多Enable_if例子 679\n28.5　一个编译时列表：Tuple 681\n28.5.1　一个简单的输出函数 683\n28.5.2　元素访问 684\n28.5.3　make_tuple 686\n28.6　可变参数模板 686\n28.6.1　一个类型安全的printf() 687\n28.6.2　技术细节 689\n28.6.3　转发 691\n28.6.4　标准库tuple 692\n28.7　国际标准单位例子 694\n28.7.1　Unit 695\n28.7.2　Quantity 696\n28.7.3　Unit字面值常量 697\n28.7.4　工具函数 698\n28.8　建议 700\n第29章　一个矩阵设计 701\n29.1　引言 701\n29.1.1　Matrix的基本使用 701\n29.1.2　对Matrix的要求 703\n29.2　Matrix模板 704\n29.2.1　构造和赋值 705\n29.2.2　下标和切片 706\n29.3　Matrix算术运算 708\n29.3.1　标量运算 709\n29.3.2　加法 710\n29.3.3　乘法 711\n29.4　Matrix实现 712\n29.4.1　slice() 713\n29.4.2　Matrix切片 713\n29.4.3　Matrix_ref 714\n29.4.4　Matrix列表初始化 715\n29.4.5　Matrix访问 717\n29.4.6　零维Matrix 719\n29.5　求解线性方程组 720\n29.5.1　经典高斯消去法 721\n29.5.2　旋转 722\n29.5.3　测试 723\n29.5.4　熔合运算 723\n29.6　建议 725","pages":"726","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28984939.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28984939.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28984939.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26857943\/","id":"26857943","publisher":"机械工业出版社","isbn10":"7111539419","isbn13":"9787111539414","title":"C++ 程序设计语言（第 1 - 3 部分）（原书第 4 版）","url":"https:\/\/api.douban.com\/v2\/book\/26857943","alt_title":"The C++ Programming Language, Fourth Edition","author_intro":"作者：（美国）本贾尼·斯特劳斯特鲁普（Bjarne Stroustrup） 译者：王刚 杨巨峰\n本贾尼·斯特劳斯特鲁普（Bjarne Stroustrup），C++语言的设计者和最初实现者，C++语言ISO标准化工作的积极参与者，同时也是《C++程序设计语言》和《C++程序设计原理与实践》的作者。他是英国剑桥大学计算机科学专业博士，1979年加入美国新泽西贝尔实验室，从成立到2002年一直担任贝尔实验室大规模程序设计研究部门的负责人。2002年至2014年，Bjarne被评为德州农工大学工程学院计算机科学首席教授，哥伦比亚大学计算机科学系客座教授，德州农工大学计算机科学系杰出研究教授。多年来，他为剑桥大学、哥伦比亚大学和普林斯顿大学等知名学府的计算机科学教学事业倾注了大量的热情和精力。商业领域方面，Bjarne是RollApp科技公司的资深顾问。2014年，Bjame加入摩根士丹利纽约总部，任职技术与数据部门的董事总经理。他是美国国家工程院院士、IEEE会士和ACM会士，研究兴趣包括分布式系统、设计、程序设计技术、软件开发工具和程序设计语言。","summary":"《C++程序设计语言》（原书第4版）是C++领域最经典的参考书，介绍了C++11的各项新特性和新功能。全书共分四部分。第一部分（第1~5章）是引言，包括C++的背景知识，C++语言及其标准库的简要介绍；第二部分（第6~15章）介绍C++的内置类型和基本特性，以及如何用它们构造程序；第三部分（第16~29章）介绍C++的抽象机制及如何用这些机制编写面向对象程序和泛型程序；第四部分（第30~44章）概述标准库并讨论一些兼容性问题。由于篇幅问题，原书中文版分两册出版，分别对应原书的第一至三部分和第四部分。这一册为第一至三部分。","series":{"id":"1163","title":"计算机科学丛书"},"price":"139.00"}