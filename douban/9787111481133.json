{"rating":{"max":10,"numRaters":26,"average":"7.6","min":0},"subtitle":"OpenGL编程指南","author":["Dave Shreiner","Graham Sellers","John Kessenich"],"pubdate":"2014-10-1","tags":[{"count":32,"name":"OpenGL","title":"OpenGL"},{"count":18,"name":"计算机图形学","title":"计算机图形学"},{"count":10,"name":"计算机","title":"计算机"},{"count":7,"name":"图形学","title":"图形学"},{"count":4,"name":"工具书","title":"工具书"},{"count":3,"name":"图像","title":"图像"},{"count":3,"name":"#OpenGL#","title":"#OpenGL#"},{"count":2,"name":"计算机科学-游戏与图形学","title":"计算机科学-游戏与图形学"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27729014.jpg","binding":"平装","translator":["王锐"],"catalog":"推荐语\n译者序\n前　言\n第1章　OpenGL概述 1\n1.1　什么是OpenGL 1\n1.2　初识OpenGL程序 2\n1.3　OpenGL语法 6\n1.4　OpenGL渲染管线 7\n1.4.1　准备向OpenGL传输数据 8\n1.4.2　将数据传输到OpenGL 8\n1.4.3　顶点着色 9\n1.4.4　细分着色 9\n1.4.5　几何着色 9\n1.4.6 　图元装配 9\n1.4.7　剪切 9\n1.4.8　光栅化 9\n1.4.9　片元着色 10\n1.4.10　逐片元的操作 10\n1.5　第一个程序：深入分析 10\n1.5.1　进入main()函数 10\n1.5.2　OpenGL的初始化过程 12\n1.5.3　第一次使用OpenGL进行渲染 21\n第2章　着色器基础 25\n2.1　着色器与OpenGL 26\n2.2　OpenGL的可编程管线 26\n2.3　OpenGL着色语言概述 28\n2.3.1　使用GLSL构建着色器 28\n2.3.2　存储限制符 34\n2.3.3　语句 37\n2.3.4　计算的不变性 41\n2.3.5　着色器的预处理器 43\n2.3.6　编译器的控制 45\n2.3.7　全局着色器编译选项 45\n2.4　数据块接口 46\n2.4.1　uniform块 46\n2.4.2　指定着色器中的uniform块 47\n2.4.3　从应用程序中访问uniform块 48\n2.4.4　buffer块 53\n2.4.5　in\/out块 54\n2.5　着色器的编译 54\n2.5.1　我们的LoadShaders()函数 58\n2.6　着色器子程序 58\n2.6.1　GLSL的子程序设置 59\n2.6.2　选择着色器子程序 60\n2.7　独立的着色器对象 62\n第3章　OpenGL绘制方式 64\n3.1　OpenGL图元 64\n3.1.1　点 65\n3.1.2　线、条带与循环线 66\n3.1.3　三角形、条带与扇面 66\n3.2　OpenGL缓存数据 69\n3.2.1　创建与分配缓存 69\n3.2.2　向缓存输入和输出数据 71\n3.2.3　访问缓存的内容 75\n3.2.4　丢弃缓存数据 80\n3.3　顶点规范 80\n3.3.1　深入讨论VertexAttrib-Pointer 81\n3.3.2　 静态顶点属性的规范 84\n3.4　OpenGL的绘制命令 86\n3.4.1　图元的重启动 92\n3.5　多实例渲染 96\n3.5.1　多实例的顶点属性 97\n3.5.2　在着色器中使用实例计数器 102\n3.5.3　多实例方法的回顾 104\n第4章　颜色、像素和帧缓存 105\n4.1　基本颜色理论 106\n4.2　缓存及其用途 107\n4.2.1　缓存的清除 109\n4.2.2　缓存的掩码 110\n4.3　颜色与OpenGL 110\n4.3.1　颜色的表达与OpenGL 111\n4.3.2　顶点颜色 112\n4.3.3　光栅化 114\n4.4　多重采样 115\n4.4.1　采样着色 116\n4.5　片元的测试与操作 117\n4.5.1　剪切测试 118\n4.5.2　多重采样的片元操作 118\n4.5.3　模板测试 119\n4.5.4　模板的例子 120\n4.5.5　深度测试 122\n4.5.6　融混 124\n4.5.7　融混参数 125\n4.5.8　控制融混的参数 125\n4.5.9　融混方程 127\n4.5.10　抖动 128\n4.5.11　逻辑操作 128\n4.5.12　遮挡查询 129\n4.5.13　条件渲染 132\n4.6　逐图元的反走样 133\n4.6.1　线段的反走样 134\n4.6.2　多边形的反走样 135\n4.7　帧缓存对象 135\n4.7.1　渲染缓存 137\n4.7.2　创建渲染缓存的存储空间 138\n4.7.3　帧缓存附件 140\n4.7.4　帧缓存的完整性 142\n4.7.5　帧缓存的无效化 144\n4.8　多重渲染缓存的同步写入 145\n4.8.1　选择颜色缓存来进行读写操作 146\n4.8.2　双源融混 148\n4.9　像素数据的读取和拷贝 150\n4.10　拷贝像素矩形 152\n第5章　视口变换、剪切与反馈 153\n5.1　观察视图 154\n5.1.1　视图模型 154\n5.1.2　相机模型 154\n5.1.3　正交视图模型 157\n5.2　用户变换 158\n5.2.1　矩阵乘法的回顾 159\n5.2.2　齐次坐标 161\n5.2.3　线性变换与矩阵 163\n5.2.4 　法线变换 173\n5.2.5　OpenGL矩阵 174\n5.3　OpenGL变换 177\n5.3.1　高级技巧：用户剪切 178\n5.4　transform feedback 179\n5.4.1　transform feedback对象 180\n5.4.2　transform feedback缓存 181\n5.4.3　配置transform feedback的变量 183\n5.4.4　transform feedback的启动和停止 187\n5.4.5　transform feedback的示例：粒子系统 189\n第6章　纹理 195\n6.1　纹理映射 196\n6.2　基本纹理类型 197\n6.3　创建和初始化纹理 198\n6.3.1　纹理格式 202\n6.4　代理纹理 207\n6.5　设置纹理数据 208\n6.5.1　显式设置纹理数据 208\n6.5.2　使用Pixel Unpack缓存 210\n6.5.3　从帧缓存拷贝数据 211\n6.5.4　从文件加载图像 212\n6.5.5　查询纹理数据 215\n6.5.6　纹理数据布局 215\n6.6　采样器对象 219\n6.6.1　采样器参数 220\n6.7　使用纹理 221\n6.7.1　纹理坐标 223\n6.7.2　组织纹理数据 226\n6.7.3　使用多重纹理 227\n6.8　复杂纹理类型 229\n6.8.1　3维纹理 229\n6.8.2　数组纹理 231\n6.8.3　立方体映射纹理 231\n6.8.4　阴影采样器 237\n6.8.5　深度模板纹理 238\n6.8.6　缓存纹理 238\n6.9　纹理视图 240\n6.10　压缩纹理 243\n6.11　滤波 245\n6.11.1　线性滤波 245\n6.11.2　使用和生成mipmap 247\n6.11.3　计算mipmap级别 251\n6.11.4　mipmap细节层次控制 252\n6.12　高级纹理查询函数 252\n6.12.1　显式细节层次 252\n6.12.2　显式梯度设置 253\n6.12.3　偏移后的纹理获取 253\n6.12.4　投影纹理 254\n6.12.5　着色器中的纹理查询 254\n6.12.6　收集纹素 256\n6.12.7　合并特殊函数 256\n6.13　点精灵 257\n6.13.1　带纹理的点精灵 257\n6.13.2　控制点的外观 259\n6.14　渲染到纹理贴图 260\n6.14.1　丢弃已渲染数据 263\n6.15　本章总结 264\n6.15.1　纹理回顾 264\n6.15.2　纹理的最好实践 265\n第7章　光照与阴影 266\n7.1　光照介绍 267\n7.2　经典光照模型 267\n7.2.1　不同光源类型的片元着色器 268\n7.2.2　将计算移到顶点着色器 277\n7.2.3　多个光源和材质 279\n7.2.4　光照坐标系统 285\n7.2.5　经典光照模型的局限 285\n7.3　光照模型进阶 286\n7.3.1　半球光照 286\n7.3.2　基于图像的光照 289\n7.3.3　球面光照 293\n7.4　阴影映射 296\n7.4.1　创建一张阴影贴图 297\n7.4.2　使用阴影贴图 299\n第8章　程序式纹理 303\n8.1　程序式纹理 303\n8.1.1　规则的花纹 305\n8.1.2　玩具球 311\n8.1.3　晶格 318\n8.1.4　程序式着色方法的总结 319\n8.2　凹凸贴图映射 319\n8.2.1　应用程序设置 321\n8.2.2　顶点着色器 323\n8.2.3　片元着色器 324\n8.2.4　法线贴图 326\n8.3　程序式纹理的反走样 326\n8.3.1　走样的来源 327\n8.3.2　避免走样问题 328\n8.3.3　提高分辨率 329\n8.3.4　高频率的反走样 330\n8.3.5　频率截断 337\n8.3.6　程序式反走样的总结 339\n8.4　噪声 339\n8.4.1　噪声的定义 341\n8.4.2　噪声纹理 345\n8.4.3　权衡 348\n8.4.4　一个简单的噪声着色器 349\n8.4.5　湍流 351\n8.4.6　大理石 353\n8.4.7　花岗岩 353\n8.4.8　木纹 354\n8.4.9　噪声的总结 357\n8.5　更多信息 357\n第9章　细分着色器 359\n9.1　细分着色器 359\n9.2　细分面片 360\n9.3　细分控制着色器 361\n9.3.1　生成输出面片的顶点 362\n9.3.2　细分控制着色器的变量 362\n9.3.3　细分的控制 363\n9.4　细分计算着色器 367\n9.4.1　设置图元生成域 368\n9.4.2　设置生成图元的面朝向 368\n9.4.3　设置细分坐标的间隔 368\n9.4.4　更多的细分计算着色器layout选项 368\n9.4.5　设置顶点的位置 369\n9.4.6　细分计算着色器的变量 369\n9.5　细分实例：茶壶 370\n9.5.1　处理面片输入顶点 370\n9.5.2　计算茶壶的细分坐标 371\n9.6　更多的细分技术 373\n9.6.1　视口相关的细分 373\n9.6.2　细分的共享边与裂缝 375\n9.6.3　置换贴图映射 376\n第10章　几何着色器 377\n10.1　创建几何着色器 378\n10.2　几何着色器的输入和输出 380\n10.2.1　几何着色器的输入 380\n10.2.2　特殊的几何着色器图元 383\n10.2.3　几何着色器的输出 387\n10.3　产生图元 389\n10.3.1　几何体的裁减 389\n10.3.2　几何体的扩充 390\n10.4　transform feedback高级篇 394\n10.4.1　多重输出流 395\n10.4.2　图元查询 399\n10.4.3　使用transform feedback的结果 400\n10.5　几何着色器的多实例化 408\n10.6　多视口与分层渲染 409\n10.6.1　视口索引 409\n10.6.2　分层渲染 414\n10.7　本章小结 417\n10.7.1　几何着色器回顾 417\n10.7.2　几何着色器的经验谈 418\n第11章　内存 420\n11.1　使用纹理存储通用数据 420\n11.1.1　将纹理绑定到图像单元 425\n11.1.2　图像数据的读取和写入 427\n11.2　着色器存储缓存对象 430\n11.2.1　写入结构化数据 431\n11.3　原子操作和同步 431\n11.3.1　图像的原子操作 431\n11.3.2　缓存的原子操作 439\n11.3.3　同步对象 440\n11.3.4　图像限定符和屏障 444\n11.3.5　高性能的原子计数器 452\n11.4　示例 455\n11.4.1　顺序无关的透明 455\n第12章　计算着色器 466\n12.1　概述 466\n12.2　工作组及其执行 467\n12.2.1　知道工作组的位置 471\n12.3　通信与同步 472\n12.3.1　通信 473\n12.3.2　同步 474\n12.4　示例 475\n12.4.1　物理模拟 476\n12.4.2　图像处理 481\n12.5　本章总结 485\n12.5.1　计算着色器回顾 485\n12.5.2　计算着色器的最佳实践 485\n附录A　GLUT基础知识 487\n附录B　OpenGL ES与WebGL 493\n附录C　内置GLSL变量与函数 504\n附录D　状态变量 552\n附录E　齐次坐标与变换矩阵 591\n附录F　OpenGL与窗口系统 596\n附录G　纹理、帧缓存与渲染缓存的浮点格式 612\n附录H　OpenGL程序的调试与优化 618\n附录I　缓存对象的布局 632\n术语表 635","pages":"668","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27729014.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27729014.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27729014.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26220248\/","id":"26220248","publisher":"机械工业出版社","isbn10":"7111481135","isbn13":"9787111481133","title":"OpenGL编程指南(原书第8版)","url":"https:\/\/api.douban.com\/v2\/book\/26220248","alt_title":"","author_intro":"Dave Shreiner，ARM公司的图形与GPU计算部门主管，自从OpenGL诞生之日起就积极地参与到它的开发当中。他创建了第一个OpenGL的商业培训课程，并且拥有超过20年的OpenGL编程教学经验。\nGraham Sellers，《OpenGL超级宝典》的联合作者，在AMD负责OpenGL的软件开发。他同时还是很多OpenGL特性规范的作者，并且协助将OpenGL ES移植到桌面计算机平台。\nJohn Kessenich，OpenGL着色语言的规范编者，LunarG公司的顾问，负责GLSL的编译器技术。他在3DLabs和Intel帮助下开发了OpenGL 2.0和OpenGL ES 2.0。\nBill Licea-Kane，AMD的技术部门核心成员，《OpenGL Shading Language Guide》的联合作者，OpenGL着色语言技术子部门的负责人。","summary":"现代OpenGL软件接口允许开发人员通过2D和3D对象、颜色图像和可编程着色器来生成高质量的计算机图像，以及交互式程序。\n《OpenGL编程指南(原书第8版)》针对OpenGL4.3版本的各种特性进行了全新阐述，并提供了有关OpenGL和OpenGL着色语言的全面介绍。本书第一次将着色器的技术与以函数功能为中心的经典技术介绍相结合。本书广泛使用了大量全新的内容和代码，将最新的OpenGL编程技术呈现在读者眼前。\n本书清晰地讲解了OpenGL的相关功能与技术，包括几何对象顶点的传递、细分，几何着色器中的几何变换，通过片元着色器来操作像素和纹理贴图，以及基于帧缓存对象和计算着色器的先进数据操作技术。\n《OpenGL编程指南(原书第8版)》共12章，主要内容有：第1章概述OpenGL主要特性和功能；第2章讨论OpenGL中最主要的特性——可编程着色器；第3章介绍使用OpenGL进行几何体绘制的各种方法，以及一些可以让渲染更为高效的优化手段；第4章阐释OpenGL对于颜色的处理过程，包括像素的处理、缓存的管理以及像素处理相关的渲染技术；第5章介绍在一个二维计算机屏幕上表现三维场景的操作细节；第6章讨论将几何模型与图像结合来创建真实的、高质量的三维模型的方法；第7章介绍计算机图形的光照效果模拟方法；第8章介绍使用可编程着色器生成纹理和其他表面效果的方法细节；第9章解释OpenGL管理和细分几何表面的着色器功能；第10章介绍在OpenGL渲染流水线中使用着色器进行几何体图元修改的特别技术；第11章介绍使用OpenGL帧缓存和缓存内存实现高级渲染技术和非图形学应用的相关方法；第12章介绍了最新的着色器阶段，将通用计算的方法融合到OpenGL的渲染流水线当中。\n本版新增OpenGL特性包括：\n有关着色器使用的最佳实践和参考代码，以及整个着色管线（包括几何和细分着色器）的详细讲解。\n通过计算着色器实现通用计算方法与渲染管线的集成。\n在应用程序运行时同时绑定多个着色器程序的技术讲解。\n用来实现先进着色技术的最新GLSL特性。\n针对图形程序性能优化的最新技术介绍。","series":{"id":"12919","title":"华章程序员书库"},"price":"129"}