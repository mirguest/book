{"rating":{"max":10,"numRaters":108,"average":"9.2","min":0},"subtitle":"","author":["【美】Marko Luksa"],"pubdate":"2019-1","tags":[{"count":125,"name":"Kubernetes","title":"Kubernetes"},{"count":68,"name":"k8s","title":"k8s"},{"count":52,"name":"容器","title":"容器"},{"count":44,"name":"docker","title":"docker"},{"count":43,"name":"云计算","title":"云计算"},{"count":36,"name":"DevOps","title":"DevOps"},{"count":34,"name":"计算机","title":"计算机"},{"count":27,"name":"容器调度","title":"容器调度"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29965036.jpg","binding":"","translator":["七牛容器云团队"],"catalog":"1  Kubernetes 介绍  1\n1.1  Kubernetes 系统的需求  2\n1.1.1  从单体应用到微服务  2\n1.1.2  为应用程序提供一个一致的环境  5\n1.1.3  迈向持续交付 ：DevOps 和无运维  6\n1.2  介绍容器技术  7\n1.2.1  什么是容器  7\n1.2.2  Docker 容器平台介绍  11\n1.2.3  rkt——一个 Docker 的替代方案  14\n1.3  Kubernetes 介绍  15\n1.3.1  初衷  15\n1.3.2  深入浅出地了解 Kubernetes  15\n1.3.3  Kubernetes 集群架构  17\n1.3.4  在 Kubernetes 中运行应用  18\n1.3.5  使用 Kubernetes 的好处  20\n1.4  本章小结  22\n2  开始使用 Kubernetes 和 Docker  23\n2.1  创建、运行及共享容器镜像  23\n2.1.1  安装 Docker 并运行 Hello World 容器  24\n2.1.2  创建一个简单的 Node.js 应用  26\n2.1.3  为镜像创建 Dockerfile  27\n2.1.4  构建容器镜像  27\n2.1.5  运行容器镜像  30\n2.1.6  探索运行容器的内部  31\n2.1.7  停止和删除容器  32\n2.1.8  向镜像仓库推送镜像  33\n2.2  配置 Kubernetes 集群  34\n2.2.1  用 Minikube 运行一个本地单节点 Kubernetes 集群  34\n2.2.2  使用 Google Kubernetes Engine 托管 Kubernetes 集群  36\n2.2.3  为 kubectl 配置别名和命令行补齐  39\n2.3  在 Kubernetes 上运行第一个应用  40\n2.3.1  部署 Node.js 应用  40\n2.3.2  访问 Web 应用  43\n2.3.3  系统的逻辑部分  45\n2.3.4  水平伸缩应用  46\n2.3.5  查看应用运行在哪个节点上  49\n2.3.6  介绍 Kubernetes dashboard  50\n2.4  本章小结  51\n3  pod ：运行于 Kubernetes 中的容器  53\n3.1  介绍 pod  53\n3.1.1  为何需要 pod  54\n3.1.2  了解 pod  55\n3.1.3  通过 pod 合理管理容器  56\n3.2  以 YAML 或 JSON 描述文件创建 pod  58\n3.2.1  检查现有 pod 的 YAML 描述文件  59\n3.2.2  为 pod 创建一个简单的 YAML 描述文件  61\n3.2.3  使用 kubectl create 来创建 pod  63\n3.2.4  查看应用程序日志  64\n3.2.5  向 pod 发送请求  65\n3.3  使用标签组织 pod  66\n3.3.1  介绍标签  66\n3.3.2  创建 pod 时指定标签  67\n3.3.3  修改现有 pod 的标签  68\n3.4  通过标签选择器列出 pod 子集  69\n3.4.1  使用标签选择器列出 pod  69\n3.4.2  在标签选择器中使用多个条件  71\n3.5  使用标签和选择器来约束 pod 调度  71\n3.5.1  使用标签分类工作节点  72\n3.5.2  将 pod 调度到特定节点  72\n3.5.3  调度到一个特定节点  73\n3.6  注解 pod  73\n3.6.1  查找对象的注解  74\n3.6.2  添加和修改注解  74\n3.7  使用命名空间对资源进行分组  75\n3.7.1  了解对命名空间的需求  75\n3.7.2  发现其他命名空间及其 pod  75\n3.7.3  创建一个命名空间  76\n3.7.4  管理其他命名空间中的对象  77\n3.7.5  命名空间提供的隔离  78\n3.8  停止和移除 pod  78\n3.8.1  按名称删除 pod  78\n3.8.2  使用标签选择器删除 pod  79\n3.8.3  通过删除整个命名空间来删除 pod  80\n3.8.4  删除命名空间中的所有 pod，但保留命名空间  80\n3.8.5  删除命名空间中的（几乎）所有资源  80\n3.9  本章小结  81\n4  副本机制和其他控制器 ：部署托管的 pod  83\n4.1  保持 pod 健康  84\n4.1.1  介绍存活探针  84\n4.1.2  创建基于 HTTP 的存活探针  85\n4.1.3  使用存活探针  86\n4.1.4  配置存活探针的附加属性  87\n4.1.5  创建有效的存活探针  88\n4.2  了解 ReplicationController  89\n4.2.1  ReplicationController 的操作  90\n4.2.2  创建一个 ReplicationController  92\n4.2.3  使用 ReplicationController  94\n4.2.4  将 pod 移入或移出 ReplicationController 的作用域  97\n4.2.5  修改 pod 模板  100\n4.2.6  水平缩放 pod  101\n4.2.7  删除一个 ReplicationController  103\n4.3  使用 ReplicaSet 而不是 ReplicationController  104\n4.3.1  比较 ReplicaSet 和 ReplicationController  104\n4.3.2  定义 ReplicaSet  105\n4.3.3  创建和检查 ReplicaSet  106\n4.3.4  使用 ReplicaSet 的更富表达力的标签选择器  106\n4.3.5  ReplicaSet 小结  107\n4.4  使用 DaemonSet 在每个节点上运行一个 pod  107\n4.4.1  使用 DaemonSet 在每个节点上运行一个 pod  108\n4.4.2  使用 DaemonSet 只在特定的节点上运行 pod  109\n4.5  运行执行单个任务的 pod  112\n4.5.1  介绍 Job 资源  112\n4.5.2  定义 Job 资源  113\n4.5.3  看 Job 运行一个 pod  114\n4.5.4  在 Job 中运行多个 pod 实例  114\n4.5.5  限制 Job pod 完成任务的时间  116\n4.6  安排 Job 定期运行或在将来运行一次  116\n4.6.1  创建一个 CronJob  116\n4.6.2  了解计划任务的运行方式  118\n4.7  本章小结  118\n5  服务 ：让客户端发现 pod 并与之通信  121\n5.1  介绍服务  122\n5.1.1  创建服务  123\n5.1.2  服务发现  129\n5.2  连接集群外部的服务  132\n5.2.1  介绍服务 endpoint  133\n5.2.2  手动配置服务的 endpoint  133\n5.2.3  为外部服务创建别名  135\n5.3  将服务暴露给外部客户端  136\n5.3.1  使用 NodePort 类型的服务  137\n5.3.2  通过负载均衡器将服务暴露出来  140\n5.3.3  了解外部连接的特性  142\n5.4  通过 Ingress 暴露服务  143\n5.4.1  创建 Ingress 资源  145\n5.4.2  通过 Ingress 访问服务  146\n5.4.3  通过相同的 Ingress 暴露多个服务  147\n5.4.4  配置 Ingress 处理 TLS 传输  149\n5.5  pod 就绪后发出信号  150\n5.5.1  介绍就绪探针  151\n5.5.2  向 pod 添加就绪探针  152\n5.5.3  了解就绪探针的实际作用  154\n5.6  使用 headless 服务来发现独立的 pod  155\n5.6.1  创建 headless 服务  156\n5.6.2  通过 DNS 发现 pod  156\n5.6.3  发现所有的 pod——包括未就绪的 pod  157\n5.7  排除服务故障  158\n5.8  本章小结  159\n6  卷 ：将磁盘挂载到容器  161\n6.1  介绍卷  162\n6.1.1  卷的应用示例  162\n6.1.2  介绍可用的卷类型  164\n6.2  通过卷在容器之间共享数据  165\n6.2.1  使用 emptyDir 卷  165\n6.2.2  使用 Git 仓库作为存储卷  168\n6.3  访问工作节点文件系统上的文件  171\n6.3.1  介绍 hostPath 卷  171\n6.3.2  检查使用 hostPath 卷的系统 pod  172\n6.4  使用持久化存储  173\n6.4.1  使用 GCE 持久磁盘作为 pod 存储卷  174\n6.4.2  通过底层持久化存储使用其他类型的卷  177\n6.5  从底层存储技术解耦 pod  179\n6.5.1  介绍持久卷和持久卷声明  179\n6.5.2  创建持久卷  180\n6.5.3  通过创建持久卷声明来获取持久卷  182\n6.5.4  在 pod 中使用持久卷声明  184\n6.5.5  了解使用持久卷和持久卷声明的好处  185\n6.5.6  回收持久卷  186\n6.6  持久卷的动态卷配置  187\n6.6.1  通过 StorageClass 资源定义可用存储类型  188\n6.6.2  请求持久卷声明中的存储类  188\n6.6.3  不指定存储类的动态配置  190\n6.7  本章小结  193\n7  ConfigMap 和 Secret ：配置应用程序  195\n7.1  配置容器化应用程序  195\n7.2  向容器传递命令行参数  196\n7.2.1  在 Docker 中定义命令与参数  196\n7.2.2  在 Kubernetes 中覆盖命令和参数  199\n7.3  为容器设置环境变量  200\n7.3.1  在容器定义中指定环境变量  201\n7.3.2  在环境变量值中引用其他环境变量  201\n7.3.3  了解硬编码环境变量的不足之处  202\n7.4  利用 ConfigMap 解耦配置  202\n7.4.1  ConfigMap 介绍  202\n7.4.2  创建 ConfigMap  203\n7.4.3  给容器传递 ConfigMap 条目作为环境变量  206\n7.4.4  一次性传递 ConfigMap 的所有条目作为环境变量  208\n7.4.5  传递 ConfigMap 条目作为命令行参数  209\n7.4.6  使用 configMap 卷将条目暴露为文件  210\n7.4.7  更新应用配置且不重启应用程序  216\n7.5  使用 Secret 给容器传递敏感数据  218\n7.5.1  介绍 Secret  218\n7.5.2  默认令牌 Secret 介绍  218\n7.5.3  创建 Secret  220\n7.5.4  对比 ConfigMap 与 Secret  221\n7.5.5  在 pod 中使用 Secret  222\n7.6  本章小结  228\n8  从应用访问 pod 元数据以及其他资源  229\n8.1  通过 Downward API 传递元数据  229\n8.1.1  了解可用的元数据  230\n8.1.2  通过环境变量暴露元数据  231\n8.1.3  通过 downwardAPI 卷来传递元数据  234\n8.2  与 Kubernetes API 服务器交互  237\n8.2.1  探究 Kubernetes REST API  238\n8.2.2  从 pod 内部与 API 服务器进行交互  242\n8.2.3  通过 ambassador 容器简化与 API 服务器的交互  248\n8.2.4  使用客户端库与 API 服务器交互  251\n8.3  本章小结  253\n9  Deployment: 声明式地升级应用  255\n9.1  更新运行在 pod 内的应用程序  256\n9.1.1  删除旧版本 pod，使用新版本 pod 替换  257\n9.1.2  先创建新 pod 再删除旧版本 pod  257\n9.2  使用 ReplicationController 实现自动的滚动升级  259\n9.2.1  运行第一个版本的应用  259\n9.2.2  使用 kubectl 来执行滚动式升级  261\n9.2.3  为什么 kubectl rolling-update 已经过时  265\n9.3  使用 Deployment 声明式地升级应用  266\n9.3.1  创建一个 Deployment  267\n9.3.2  升级 Deployment  269\n9.3.3  回滚 Deployment  273\n9.3.4  控制滚动升级速率  276\n9.3.5  暂停滚动升级  278\n9.3.6  阻止出错版本的滚动升级  279\n9.4  本章小结  284\n10  StatefulSet ：部署有状态的多副本应用  285\n10.1  复制有状态 pod  285\n10.1.1  运行每个实例都有单独存储的多副本  286\n10.1.2  每个 pod 都提供稳定的标识  287\n10.2  了解 Statefulset  289\n10.2.1  对比 Statefulset 和 ReplicaSet  289\n10.2.2  提供稳定的网络标识  290\n10.2.3  为每个有状态实例提供稳定的专属存储  292\n10.2.4  Statefulset 的保障  294\n10.3  使用 Statefulset  295\n10.3.1  创建应用和容器镜像  295\n10.3.2  通过 Statefulset 部署应用  296\n10.3.3  使用你的 pod  301\n10.4  在 Statefulset 中发现伙伴节点  305\n10.4.1  通过 DNS 实现伙伴间彼此发现  306\n10.4.2  更新 Statefulset  308\n10.4.3  尝试集群数据存储  309\n10.5  了解 Statefulset 如何处理节点失效  310\n10.5.1  模拟一个节点的网络断开  310\n10.5.2  手动删除 pod  312\n10.6  本章小结  313\n11  了解 Kubernetes 机理  315\n11.1  了解架构  315\n11.1.1  Kubernetes 组件的分布式特性  316\n11.1.2  Kubernetes 如何使用 etcd  318\n11.1.3  API 服务器做了什么  322\n11.1.4  API 服务器如何通知客户端资源变更  324\n11.1.5  了解调度器  325\n11.1.6  介绍控制器管理器中运行的控制器  327\n11.1.7  Kubelet 做了什么  331\n11.1.8  Kubernetes Service Proxy 的作用  332\n11.1.9  介绍 Kubernetes 插件  333\n11.1.10  总结概览  335\n11.2  控制器如何协作  335\n11.2.1  了解涉及哪些组件  335\n11.2.2  事件链  336\n11.2.3  观察集群事件  337\n11.3  了解运行中的 pod 是什么  339\n11.4  跨 pod 网络  340\n11.4.1  网络应该是什么样的  340\n11.4.2  深入了解网络工作原理  341\n11.4.3  引入容器网络接口  343\n11.5  服务是如何实现的  344\n11.5.1  引入 kube-proxy  344\n11.5.2  kube-proxy 如何使用 iptables  344\n11.6  运行高可用集群  346\n11.6.1  让你的应用变得高可用  346\n11.6.2  让 Kubernetes 控制平面变得高可用  347\n11.7  本章小结  350\n12  Kubernetes API 服务器的安全防护  351\n12.1  了解认证机制  351\n12.1.1  用户和组  352\n12.1.2  ServiceAccount 介绍  353\n12.1.3  创建 ServiceAccount  354\n12.1.4  将 ServiceAccount 分配给 pod  356\n12.2  通过基于角色的权限控制加强集群安全  358\n12.2.1  介绍 RBAC 授权插件  359\n12.2.2  介绍 RBAC 资源  360\n12.2.3  使用 Role 和 RoleBinding  363\n12.2.4  使用 ClusterRole 和 ClusterRoleBinding  367\n12.2.5  了解默认的 ClusterRole 和 ClusterRoleBinding  376\n12.2.6  理性地授予授权权限  379\n12.3  本章小结  379\n13  保障集群内节点和网络安全  381\n13.1  在 pod 中使用宿主节点的 Linux 命名空间  381\n13.1.1  在 pod 中使用宿主节点的网络命名空间  382\n13.1.2  绑定宿主节点上的端口而不使用宿主节点的网络命名空间  383\n13.1.3  使用宿主节点的 PID 与 IPC 命名空间  385\n13.2  配置节点的安全上下文  386\n13.2.1  使用指定用户运行容器  387\n13.2.2  阻止容器以 root 用户运行  388\n13.2.3  使用特权模式运行 pod  389\n13.2.4  为容器单独添加内核功能  390\n13.2.5  在容器中禁用内核功能  391\n13.2.6  阻止对容器根文件系统的写入  392\n13.2.7  容器使用不同用户运行时共享存储卷  394\n13.3  限制 pod 使用安全相关的特性  396\n13.3.1  PodSecurityPolicy 资源介绍  396\n13.3.2  了解 runAsUser、 fsGroup 和 supplementalGroup 策略  398\n13.3.3  配置允许、默认添加、禁止使用的内核功能  400\n13.3.4  限制 pod 可以使用的存储卷类型  402\n13.3.5  对不同的用户与组分配不同的 PodSecurityPolicy  402\n13.4  隔离 pod 的网络  406\n13.4.1  在一个命名空间中启用网络隔离  406\n13.4.2  允许同一命名空间中的部分 pod 访问一个服务端 pod  407\n13.4.3  在不同 Kubernetes 命名空间之间进行网络隔离  408\n13.4.4  使用 CIDR 隔离网络  409\n13.4.5  限制 pod 的对外访问流量  409\n13.5  本章小结  410\n14  计算资源管理  411\n14.1  为 pod 中的容器申请资源  411\n14.1.1  创建包含资源 requests 的 pod  412\n14.1.2  资源 requests 如何影响调度  413\n14.1.3  CPU requests 如何影响 CPU 时间分配  418\n14.1.4  定义和申请自定义资源  418\n14.2  限制容器的可用资源  419\n14.2.1  设置容器可使用资源量的硬限制  419\n14.2.2  超过 limits  421\n14.2.3  容器中的应用如何看待 limits  422\n14.3  了解 pod QoS 等级  423\n14.3.1  定义 pod 的 QoS 等级  424\n14.3.2  内存不足时哪个进程会被杀死  426\n14.4  为命名空间中的 pod 设置默认的 requests 和 limits  427\n14.4.1  LimitRange 资源简介  428\n14.4.2  LimitRange 对象的创建  428\n14.4.3  强制进行限制  430\n14.4.4  应用资源 requests 和 limits 的默认值  430\n14.5  限制命名空间中的可用资源总量  431\n14.5.1  ResourceQuota 资源介绍  431\n14.5.2  为持久化存储指定配额  434\n14.5.3  限制可创建对象的个数  434\n14.5.4  为特定的 pod 状态或者 QoS 等级指定配额  435\n14.6  监控 pod 的资源使用量  436\n14.6.1  收集、获取实际资源使用情况  437\n14.6.2  保存并分析历史资源的使用统计信息  439\n14.7  本章小结  442\n15  自动横向伸缩 pod 与集群节点  443\n15.1  pod 的横向自动伸缩  444\n15.1.1  了解自动伸缩过程  444\n15.1.2  基于 CPU 使用率进行自动伸缩  447\n15.1.3  基于内存使用进行自动伸缩  453\n15.1.4  基于其他自定义度量进行自动伸缩  453\n15.1.5  确定哪些度量适合用于自动伸缩  456\n15.1.6  缩容到 0 个副本  456\n15.2  pod 的纵向自动伸缩  456\n15.2.1  自动配置资源请求  457\n15.2.2  修改运行中 pod 的资源请求  457\n15.3  集群节点的横向伸缩  457\n15.3.1  Cluster Autoscaler 介绍  457\n15.3.2  启用 Cluster Autoscaler  459\n15.3.3  限制集群缩容时的服务干扰  460\n15.4  本章小结  461\n16  高级调度  463\n16.1  使用污点和容忍度阻止节点调度到特定节点  463\n16.1.1  介绍污点和容忍度  464\n16.1.2  在节点上添加自定义污点  466\n16.1.3  在 pod 上添加污点容忍度  467\n16.1.4  了解污点和污点容忍度的使用场景  467\n16.2  使用节点亲缘性将 pod 调度到特定节点上  469\n16.2.1  指定强制性节点亲缘性规则  470\n16.2.2  调度 pod 时优先考虑某些节点  472\n16.3  使用 pod 亲缘性与非亲缘性对 pod 进行协同部署  475\n16.3.1  使用 pod 间亲缘性将多个 pod 部署在同一个节点上  475\n16.3.2  将 pod 部署在同一机柜、可用性区域或者地理地域  478\n16.3.3  表达 pod 亲缘性优先级取代强制性要求  479\n16.3.4  利用 pod 的非亲缘性分开调度 pod  481\n16.4  本章小结  483\n17  开发应用的最佳实践  485\n17.1  集中一切资源  486\n17.2  了解 pod 的生命周期  487\n17.2.1  应用必须预料到会被杀死或者重新调度  487\n17.2.2  重新调度死亡的或者部分死亡的 pod  490\n17.2.3  以固定顺序启动 pod  491\n17.2.4  增加生命周期钩子  493\n17.2.5  了解 pod 的关闭  497\n17.3  确保所有的客户端请求都得到了妥善处理  500\n17.3.1  在 pod 启动时避免客户端连接断开  500\n17.3.2  在 pod 关闭时避免客户端连接断开  501\n17.4  让应用在 Kubernetes 中方便运行和管理  505\n17.4.1  构建可管理的容器镜像  505\n17.4.2  合理地给镜像打标签，正确地使用 ImagePullPolicy  506\n17.4.3  使用多维度而不是单维度的标签  506\n17.4.4  通过注解描述每个资源  506\n17.4.5  给进程终止提供更多的信息  507\n17.4.6  处理应用日志  508\n17.5  开发和测试的最佳实践  510\n17.5.1  开发过程中在 Kubernetes 之外运行应用  510\n17.5.2  在开发过程中使用 Minikube  512\n17.5.3  发布版本和自动部署资源清单  513\n17.5.4  使用 Ksonnet 作为编写 YAML\/JSON manifest文件的额外选择  513\n17.5.5  利用持续集成和持续交付  514\n17.6  本章小结  515\n18  Kubernetes 应用扩展  517\n18.1  定义自定义 API 对象  517\n18.1.1  CustomResourceDefinitions 介绍  518\n18.1.2  使用自定义控制器自动定制资源  522\n18.1.3  验证自定义对象  526\n18.1.4  为自定义对象提供自定义 API 服务器  527\n18.2  使用 Kubernetes 服务目录扩展 Kubernetes  528\n18.2.1  服务目录介绍  529\n18.2.2  服务目录 API 服务器与控制器管理器介绍  530\n18.2.3  Service 代理和 OpenServiceBroker API  530\n18.2.4  提供服务与使用服务  533\n18.2.5  解除绑定与取消配置  535\n18.2.6  服务目录给我们带来了什么  535\n18.3  基于 Kubernetes 搭建的平台  536\n18.3.1  红帽 OpenShift 容器平台  536\n18.3.2  Deis Workflow 与 Helm  539\n18.4  本章小结  541\nA  在多个集群中使用 kubectl  543\nB  使用 kubeadm 配置多节点集群  549\nC  使用其他容器运行时  563\nD  Cluster Federation  567","pages":"592","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29965036.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29965036.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29965036.jpg"},"alt":"https:\/\/book.douban.com\/subject\/30418855\/","id":"30418855","publisher":"电子工业出版社","isbn10":"7121349957","isbn13":"9787121349959","title":"Kubernetes in Action中文版","url":"https:\/\/api.douban.com\/v2\/book\/30418855","alt_title":"","author_intro":"Marko Luksa是一位拥有20年以上专业开发经验的软件工程师，经手项目小到简单的Web应用，大到ERP系统、框架和中间件软件，应有尽有。在为Red Hat工作期间，他从Google App Engine API实现的开发起步, 这些API将基于Red Hat的JBoss中间件产品，之后他一直在为CDI\/Weld、Infinispan\/JBoss DataGrid等项目贡献力量。2014后, 他加入Red Hat的Cloud Enablement团队，负责 Kubernetes和相关技术开发的更新，保障公司的中间件软件能将Kubernetes与OpenShift特性的潜能用到极致。\n译者简介\n七牛容器云 （KIRK）团队，是负责七牛云基于自身公有云业务在容器方面的多年实践经验，针对企业应用快速部署、便捷运维打造的容器云计算平台。提供持续集成、弹性伸缩、应用市场等功能特性，使企业专注于业务逻辑开发，缩短业务上线周期，优化资源利用率，提高服务响应效率的一支技术团队。","summary":"《Kubernetes in Action中文版》主要讲解如何在 Kubernetes 中部署分布式容器应用。《Kubernetes in Action中文版》开始部分概要介绍了 Docker 和Kubernetes 的由来和发展，然后通过在 Kubernetes 中部署一个应用程序，一点点增加功能，逐步加深我们对于Kubernetes架构的理解和操作的实践。在本书的后面部分，也可以学习一些高阶的主题，比如监控、调试及伸缩。\nKubernetes是希腊文，意思是“舵手”，带领我们安全地到达未知水域。Kubernetes这样的容器编排系统，会帮助我们妥善地管理分布式应用的部署结构和线上流量，高效地组织容器和服务。Kubernetes 作为数据中心操作系统，在设计软件系统时，能够尽量降低在底层网络和硬件设施上的负担。","price":"148"}