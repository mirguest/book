{"rating":{"max":10,"numRaters":636,"average":"9.3","min":0},"subtitle":"第3版","author":["施瓦茨 (Baron Schwartz)","扎伊采夫 (Peter Zaitsev)","特卡琴科 (Vadim Tkachenko)"],"pubdate":"2013-5-1","tags":[{"count":1079,"name":"MySQL","title":"MySQL"},{"count":743,"name":"数据库","title":"数据库"},{"count":378,"name":"高性能MySQL","title":"高性能MySQL"},{"count":267,"name":"计算机","title":"计算机"},{"count":179,"name":"mysql","title":"mysql"},{"count":141,"name":"编程","title":"编程"},{"count":137,"name":"计算机科学","title":"计算机科学"},{"count":99,"name":"软件开发","title":"软件开发"}],"origin_title":"High Performance MySQL,3rd","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s27783358.jpg","binding":"平装","translator":["宁海元","周振兴","彭立勋","翟卫祥,刘辉"],"catalog":"推荐序 xxiii\n前言 xxv\n第1 章 mysql 架构与历史 1\n1.1 mysql 逻辑架构 1\n1.1.1 连接管理与安全性2\n1.1.2 优化与执行 3\n1.2 并发控制 3\n1.2.1 读写锁 4\n1.2.2 锁粒度 4\n1.3 事务6\n1.3.1 隔离级别 8\n1.3.2 死锁 9\n1.3.3 事务日志 10\n1.3.4 mysql 中的事务 10\n1.4 多版本并发控制 12\n1.5 mysql 的存储引擎 13\n1.5.1 innodb 存储引擎 16\n1.5.2 myisam 存储引擎 17\n1.5.3 mysql 内建的其他存储引擎 19\n.1.5.4 第三方存储引擎 22\n1.5.5 选择合适的引擎 24\n1.5.6 转换表的引擎 27\n1.6 mysql 时间线（timeline） 29\n1.7 mysql 的开发模式 32\n1.8 总结 33\n第2 章 mysql 基准测试 35\n2.1 为什么需要基准测试 35\n2.2 基准测试的策略 37\n2.2.1 测试何种指标 38\n2.3 基准测试方法 40\n2.3.1 设计和规划基准测试 41\n2.3.2 基准测试应该运行多长时间 42\n2.3.3 获取系统性能和状态 43\n2.3.4 获得准确的测试结果 44\n2.3.5 运行基准测试并分析结果 46\n2.3.6 绘图的重要性 47\n2.4 基准测试工具 49\n2.4.1 集成式测试工具 49\n2.4.2 单组件式测试工具 50\n2.5 基准测试案例 52\n2.5.1 http_load 53\n2.5.2 mysql 基准测试套件 54\n2.5.3 sysbench 55\n2.5.4 数据库测试套件中的dbt2 tpc-c 测试 60\n2.5.5 percona 的tpcc-mysql 测试工具 63\n2.6 总结 65\n第3 章 服务器性能剖析 67\n3.1 性能优化简介 67\n3.1.1 通过性能剖析进行优化 69\n3.1.2 理解性能剖析 71\n3.2 对应用程序进行性能剖析 72\n3.2.1 测量php 应用程序 74\n3.3 剖析mysql 查询 77\n3.3.1 剖析服务器负载 77\n3.3.2 剖析单条查询 81\n3.3.3 使用性能剖析 87\n3.4 诊断间歇性问题 88\n3.4.1 单条查询问题还是服务器问题 89\n3.4.2 捕获诊断数据 93\n3.4.3 一个诊断案例 98\n3.5 其他剖析工具 106\n3.5.1 使用user_statistics 表 106\n3.5.2 使用strace 107\n3.6 总结 108\n第4 章 schema 与数据类型优化 111\n4.1 选择优化的数据类型 111\n4.1.1 整数类型 113\n4.1.2 实数类型 113\n4.1.3 字符串类型 114\n4.1.4 日期和时间类型 121\n4.1.5 位数据类型 123\n4.1.6 选择标识符（identifier） 125\n4.1.7 特殊类型数据 127\n4.2 mysql schema 设计中的陷阱 127\n4.3 范式和反范式 129\n4.3.1 范式的优点和缺点 130\n4.3.2 反范式的优点和缺点 130\n4.3.3 混用范式化和反范式化 131\n4.4 缓存表和汇总表 132\n4.4.1 物化视图 134\n4.4.2 计数器表 135\n4.5 加快alter table 操作的速度 136\n4.5.1 只修改.frm 文件 137\n4.5.2 快速创建myisam 索引 139\n4.6 总结 140\n第5 章 创建高性能的索引 141\n5.1 索引基础 141\n5.1.1 索引的类型 142\n5.2 索引的优点 152\n5.3 高性能的索引策略 153\n5.3.1 独立的列 153\n5.3.2 前缀索引和索引选择性 153\n5.3.3 多列索引 157\n5.3.4 选择合适的索引列顺序 159\n5.3.5 聚簇索引 162\n5.3.6 覆盖索引 171\n5.3.7 使用索引扫描来做排序 175\n5.3.8 压缩（前缀压缩）索引 177\n5.3.9 冗余和重复索引 178\n5.3.10 未使用的索引 181\n5.3.11 索引和锁 181\n5.4 索引案例学习 183\n5.4.1 支持多种过滤条件 183\n5.4.2 避免多个范围条件 185\n5.4.3 优化排序 186\n5.5 维护索引和表 187\n5.5.1 找到并修复损坏的表 187\n5.5.2 更新索引统计信息 188\n5.5.3 减少索引和数据的碎片 190\n5.6 总结 192\n第6 章 查询性能优化 195\n6.1 为什么查询速度会慢 195\n6.2 慢查询基础：优化数据访问 196\n6.2.1 是否向数据库请求了不需要的数据 196\n6.2.2 mysql 是否在扫描额外的记录 198\n6.3 重构查询的方式 201\n6.3.1 一个复杂查询还是多个简单查询 201\n6.3.2 切分查询 202\n6.3.3 分解关联查询 203\n6.4 查询执行的基础 204\n6.4.1 mysql 客户端\/ 服务器通信协议 205\n6.4.2 查询缓存 208\n6.4.3 查询优化处理 208\n6.4.4 查询执行引擎 222\n6.4.5 返回结果给客户端 223\n6.5 mysql 查询优化器的局限性 223\n6.5.1 关联子查询 223\n6.5.2 union 的限制 228\n6.5.3 索引合并优化 228\n6.5.4 等值传递 229\n6.5.5 并行执行 229\n6.5.6 哈希关联 229\n6.5.7 松散索引扫描 229\n6.5.8 最大值和最小值优化 231\n6.5.9 在同一个表上查询和更新 232\n6.6 查询优化器的提示（hint） 232\n6.7 优化特定类型的查询 236\n6.7.1 优化count() 查询 236\n6.7.2 优化关联查询 239\n6.7.3 优化子查询 239\n6.7.4 优化group by 和distinct 239\n6.7.5 优化limit 分页 241\n6.7.6 优化sql_calc_found_rows 243\n6.7.7 优化union 查询 243\n6.7.8 静态查询分析 244\n6.7.9 使用用户自定义变量 244\n6.8 案例学习 251\n6.8.1 使用mysql 构建一个队列表 251\n6.8.2 计算两点之间的距离 254\n6.8.3 使用用户自定义函数 257\n6.9 总结 258\n第7 章 mysql 高级特性 259\n7.1 分区表 259\n7.1.1 分区表的原理 260\n7.1.2 分区表的类型 261\n7.1.3 如何使用分区表 262\n7.1.4 什么情况下会出问题 263\n7.1.5 查询优化 266\n7.1.6 合并表 267\n7.2 视图 270\n7.2.1 可更新视图 272\n7.2.2 视图对性能的影响 273\n7.2.3 视图的限制 274\n7.3 外键约束 275\n7.4 在mysql 内部存储代码 276\n7.4.1 存储过程和函数 278\n7.4.2 触发器 279\n7.4.3 事件 281\n7.4.4 在存储程序中保留注释 283\n7.5 游标 283\n7.6 绑定变量 284\n7.6.1 绑定变量的优化 286\n7.6.2 sql 接口的绑定变量 286\n7.6.3 绑定变量的限制 288\n7.7 用户自定义函数 289\n7.8 插件 290\n7.9 字符集和校对 291\n7.9.1 mysql 如何使用字符集 292\n7.9.2 选择字符集和校对规则 295\n7.9.3 字符集和校对规则如何影响查询 296\n7.10 全文索引 299\n7.10.1 自然语言的全文索引 300\n7.10.2 布尔全文索引 302\n7.10.3 mysql5.1 中全文索引的变化 303\n7.10.4 全文索引的限制和替代方案 304\n7.10.5 全文索引的配置和优化 306\n7.11 分布式（xa）事务 307\n7.11.1 内部xa 事务 307\n7.11.2 外部xa 事务 308\n7.12 查询缓存 309\n7.12.1 mysql 如何判断缓存命中 309\n7.12.2 查询缓存如何使用内存 311\n7.12.3 什么情况下查询缓存能发挥作用 313\n7.12.4 如何配置和维护查询缓存 316\n7.12.5 innodb 和查询缓存 319\n7.12.6 通用查询缓存优化 320\n7.12.7 查询缓存的替代方案 321\n7.13 总结 321\n第8 章 优化服务器设置 325\n8.1 mysql 配置的工作原理 326\n8.1.1 语法、作用域和动态性 327\n8.1.2 设置变量的副作用 328\n8.1.3 入门 331\n8.1.4 通过基准测试迭代优化 332\n8.2 什么不该做 333\n8.3 创建mysql 配置文件 335\n8.3.1 检查mysql 服务器状态变量 339\n8.4 配置内存使用 340\n8.4.1 mysql 可以使用多少内存？ 340\n8.4.2 每个连接需要的内存 341\n8.4.3 为操作系统保留内存 341\n8.4.4 为缓存分配内存 342\n8.4.5 innodb 缓冲池（buffer pool） 342\n8.4.6 myisam 键缓存（key caches） 344\n8.4.7 线程缓存 346\n8.4.8 表缓存（table cache） 347\n8.4.9 innodb 数据字典（data dictionary） 348\n8.5 配置mysql 的i\/o 行为 349\n8.5.1 innodb i\/o 配置 349\n8.5.2 myisam 的i\/o 配置 361\n8.6 配置mysql 并发 363\n8.6.1 innodb 并发配置 364\n8.6.2 myisam 并发配置 365\n8.7 基于工作负载的配置 366\n8.7.1 优化blob 和text 的场景 367\n8.7.2 优化排序（filesorts） 368\n8.8 完成基本配置 369\n8.9 安全和稳定的设置 371\n8.10 高级innodb 设置 374\n8.11 总结 376\n第9 章 操作系统和硬件优化 377\n9.1 什么限制了mysql 的性能 377\n9.2 如何为mysql 选择cpu 378\n9.2.1 哪个更好：更快的cpu 还是更多的cpu 378\n9.2.2 cpu 架构 380\n9.2.3 扩展到多个cpu 和核心 381\n9.3 平衡内存和磁盘资源 382\n9.3.1 随机i\/o 和顺序i\/o 383\n9.3.2 缓存，读和写 384\n9.3.3 工作集是什么 385\n9.3.4 找到有效的内存\/ 磁盘比例 386\n9.3.5 选择硬盘 387\n9.4 固态存储 389\n9.4.1 闪存概述 390\n9.4.2 闪存技术 391\n9.4.3 闪存的基准测试 392\n9.4.4 固态硬盘驱动器（ssd） 393\n9.4.5 pcie 存储设备 395\n9.4.6 其他类型的固态存储 396\n9.4.7 什么时候应该使用闪存 396\n9.4.8 使用flashcache 397\n9.4.9 优化固态存储上的mysql 399\n9.5 为备库选择硬件 402\n9.6 raid 性能优化 403\n9.6.1 raid 的故障转移、恢复和镜像 405\n9.6.2 平衡硬件raid 和软件raid 406\n9.6.3 raid 配置和缓存 407\n9.7 san 和nas 410\n9.7.1 san 基准测试 411\n9.7.2 使用基于nfs 或smb 的san 412\n9.7.3 mysql 在san 上的性能 412\n9.7.4 应该用san 吗 413\n9.8 使用多磁盘卷 414\n9.9 网络配置 416\n9.10 选择操作系统 418\n9.11 选择文件系统 419\n9.12 选择磁盘队列调度策略 421\n9.13 线程 422\n9.14 内存交换区 422\n9.15 操作系统状态 424\n9.15.1 如何阅读vmstat 的输出 425\n9.15.2 如何阅读iostat 的输出 426\n9.15.3 其他有用的工具 428\n9.15.4 cpu 密集型的机器 428\n9.15.5 i\/o 密集型的机器 429\n9.15.6 发生内存交换的机器 430\n9.15.7 空闲的机器 430\n9.16 总结 431\n第10 章 复制 433\n10.1 复制概述 433\n10.1.1 复制解决的问题 434\n10.1.2 复制如何工作 435\n10.2 配置复制 436\n10.2.1 创建复制账号 437\n10.2.2 配置主库和备库 437\n10.2.3 启动复制 439\n10.2.4 从另一个服务器开始复制 441\n10.2.5 推荐的复制配置 443\n10.3 复制的原理 445\n10.3.1 基于语句的复制 445\n10.3.2 基于行的复制 446\n10.3.3 基于行或基于语句：哪种更优 446\n10.3.4 复制文件 448\n10.3.5 发送复制事件到其他备库 449\n10.3.6 复制过滤器 450\n10.4 复制拓扑 452\n10.4.1 一主库多备库 452\n10.4.2 主动- 主动模式下的主- 主复制 453\n10.4.3 主动- 被动模式下的主- 主复制 455\n10.4.4 拥有备库的主- 主结构 456\n10.4.5 环形复制 457\n10.4.6 主库、分发主库以及备库 458\n10.4.7 树或金字塔形 460\n10.4.8 定制的复制方案 460\n10.5 复制和容量规划 465\n10.5.1 为什么复制无法扩展写操作 466\n10.5.2 备库什么时候开始延迟 466\n10.5.3 规划冗余容量 467\n10.6 复制管理和维护 468\n10.6.1 监控复制 468\n10.6.2 测量备库延迟 469\n10.6.3 确定主备是否一致 469\n10.6.4 从主库重新同步备库 470\n10.6.5 改变主库 471\n10.6.6 在一个主- 主配置中交换角色 476\n10.7 复制的问题和解决方案 477\n10.7.1 数据损坏或丢失的错误 477\n10.7.2 使用非事务型表 480\n10.7.3 混合事务型和非事务型表 480\n10.7.4 不确定语句 481\n10.7.5 主库和备库使用不同的存储引擎 481\n10.7.6 备库发生数据改变 481\n10.7.7 不唯一的服务器id 482\n10.7.8 未定义的服务器id 482\n10.7.9 对未复制数据的依赖性 482\n10.7.10 丢失的临时表 483\n10.7.11 不复制所有的更新 484\n10.7.12 innodb 加锁读引起的锁争用 484\n10.7.13 在主- 主复制结构中写入两台主库 486\n10.7.14 过大的复制延迟 488\n10.7.15 来自主库的过大的包 491\n10.7.16 受限制的复制带宽 491\n10.7.17 磁盘空间不足 492\n10.7.18 复制的局限性 492\n10.8 复制有多快 492\n10.9 mysql 复制的高级特性 494\n10.10 其他复制技术 496\n10.11 总结 498\n第11 章 可扩展的mysql 501\n11.1 什么是可扩展性 501\n11.1.1 正式的可扩展性定义 503\n11.2 扩展mysql 507\n11.2.1 规划可扩展性 507\n11.2.2 为扩展赢得时间 508\n11.2.3 向上扩展 509\n11.2.4 向外扩展 510\n11.2.5 通过多实例扩展 525\n11.2.6 通过集群扩展 526\n11.2.7 向内扩展 530\n11.3 负载均衡 532\n11.3.1 直接连接 534\n11.3.2 引入中间件 537\n11.3.3 一主多备间的负载均衡 540\n11.4 总结 541\n第12 章 高可用性 543\n12.1 什么是高可用性 543\n12.2 导致宕机的原因 544\n12.3 如何实现高可用性 545\n12.3.1 提升平均失效时间（mtbf） 545\n12.3.2 降低平均恢复时间（mttr） 547\n12.4 避免单点失效 548\n12.4.1 共享存储或磁盘复制 549\n12.4.2 mysql 同步复制 551\n12.4.3 基于复制的冗余 555\n12.5 故障转移和故障恢复 556\n12.5.1 提升备库或切换角色 558\n12.5.2 虚拟ip 地址或ip 接管 558\n12.5.3 中间件解决方案 559\n12.5.4 在应用中处理故障转移 560\n12.6 总结 560\n第13 章 云端的mysql 563\n13.1 云的优点、缺点和相关误解 564\n13.2 mysql 在云端的经济价值 566\n13.3 云中的mysql 的可扩展性和高可用性 567\n13.4 四种基础资源 568\n13.5 mysql 在云主机上的性能 569\n13.5.1 在云端的mysql 基准测试 571\n13.6 mysql 数据库即服务（dbaas） 573\n13.6.1 amazon rds 573\n13.6.2 其他dbaas 解决方案 574\n13.7 总结 575\n第14 章 应用层优化 577\n14.1 常见问题 577\n14.2 web 服务器问题 579\n14.2.1 寻找最优并发度 581\n14.3 缓存 582\n14.3.1 应用层以下的缓存 583\n14.3.2 应用层缓存 584\n14.3.3 缓存控制策略 586\n14.3.4 缓存对象分层 587\n14.3.5 预生成内容 588\n14.3.6 作为基础组件的缓存 589\n14.3.7 使用handlersocket 和memcached 589\n14.4 拓展mysql 590\n14.5 mysql 的替代品 590\n14.6 总结 591\n第15 章 备份与恢复 593\n15.1 为什么要备份 594\n15.2 定义恢复需求 595\n15.3 设计mysql 备份方案 596\n15.3.1 在线备份还是离线备份 597\n15.3.2 逻辑备份还是物理备份 598\n15.3.3 备份什么 601\n15.3.4 存储引擎和一致性 603\n15.4 管理和备份二进制日志 605\n15.4.1 二进制日志格式 606\n15.4.2 安全地清除老的二进制日志 607\n15.5 备份数据 607\n15.5.1 生成逻辑备份 607\n15.5.2 文件系统快照 610\n15.6 从备份中恢复 617\n15.6.1 恢复物理备份 618\n15.6.2 还原逻辑备份 619\n15.6.3 基于时间点的恢复 622\n15.6.4 更高级的恢复技术 624\n15.6.5 innodb 崩溃恢复 625\n15.7 备份和恢复工具 628\n15.7.1 mysql enterprise backup 628\n15.7.2 percona xtrabackup 628\n15.7.3 mylvmbackup 629\n15.7.4 zmanda recovery manager 629\n15.7.5 mydumper 629\n15.7.6 mysqldump 629\n15.8 备份脚本化 631\n15.9 总结 633\n第16 章 mysql 用户工具 635\n16.1 接口工具 635\n16.2 命令行工具集 636\n16.3 sql 实用集 637\n16.4 监测工具 637\n16.4.1 开源的监控工具 638\n16.4.2 商业监控系统 640\n16.4.3 innotop 的命令行监控 642\n16.5 总结 646\n附录a mysql 分支与变种 649\n附录b mysql 服务器状态 655\n附录c 大文件传输 683\n附录d explain 687\n附录e 锁的调试 703\n附录f 在mysql 上使用sphinx 713\n索引 739","ebook_url":"https:\/\/read.douban.com\/ebook\/35648568\/","pages":"764","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s27783358.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s27783358.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s27783358.jpg"},"alt":"https:\/\/book.douban.com\/subject\/23008813\/","id":"23008813","publisher":"电子工业出版社","isbn10":"7121198851","isbn13":"9787121198854","title":"高性能MySQL","url":"https:\/\/api.douban.com\/v2\/book\/23008813","alt_title":"High Performance MySQL,3rd","author_intro":"关于作者\nBaron Schwartz 是一位软件工程师，居住在弗吉尼亚州的Charlottesville，网络常用名是Xaprb，这是按照QWERTY 键盘的顺序在Dvorak 键盘上打出来的名字。在不忙于解决有趣的编程挑战时，Baron 会和他的妻子Lynn 以及小狗Carbon 一起享受闲暇的时光。他有一个软件工程方面的博客，地址是http:\/\/www.xaprb.com\/blog\/\nPeter Zaitsev 曾经是MySQL AB 公司高性能组的经理，目前在运作mysqlperformance\nblog.com 网站。他擅长于帮助那些每天有数以百万计访问量的网站的管理员解决问题，这些网站通常需要几百台机器来处理TB 级的数据。他常常为了解决一个问题而不停地升级硬件和软件（比如查询优化）。Peter 还经常在各种会议上演讲。\nVadim Tkachenko 曾经是MySQL AB 公司的性能工程师。作为一名在多线程编程和同步方面的专家，他的主要工作是基准测试、性能剖析，以及找出系统的性能瓶颈。他还在性能监控和调优方面做了一些工作，使得MySQL 在多核机器上有更好的可扩展性。\n================================================================\n译者简介\n宁海元 有超过十年的数据库管理经验，从最初到SQL Server 2000到Oracle到MySQL，擅长数据库高可用架构，性能优化和故障诊断。2007年加入淘宝，带领淘宝DBA团队支撑了淘宝业务的快速增长，完成了数据库的垂直拆分、水平拆分，迁移到MySQL体系等主要工作。目前专注于无线数据领域。网络常用名NinGoo，个人博客：http:\/\/www.ningoo.net\n周振兴 毕业于北京师范大学数学系，09年加入淘宝数据库团队负责MySQL运维管理工作，有丰富的MySQL性能优化、Troubleshooting经验，对MySQL主要模块的实现和原理有深入的研究，经历淘宝MySQL实例从30到3000的发展，对系统架构、高可用环境规划都有深入理解。个人博客：http:\/\/orczhou.com\n彭立勋 2010年大学毕业后加入阿里巴巴运维部。作为一名MySQL DBA，在运维MySQL的过程中，对MySQL和InnoDB的一些功能和缺陷就进行了补充，编写了多主复制和数据闪回等补丁。目前在阿里集团核心系统研发部数据库组，专注于MySQL数据库相关的开发工作。后来一些补丁被MySQL之父Mony看中，成为MariaDB提交组（Maria-captains）成员，并且把多主复制，线程内存监控等补丁合并到了MariaDB 10.0版本。\n翟卫祥 毕业于武汉大学，研究生阶段从事数据库相关研究。毕业后就职于阿里巴巴集团数据库技术团队至今，主要负责阿里内部MySQL代码分支维护，包括MySQL Bug Fix及新特性开发。对MySQL内核有一定的研究。\n刘辉 2008年毕业于西安电子科技大学计算机系，硕士学位。2011年加入阿里巴巴集团数据库技术团队，花名希羽，MySQL内核开发工程师。","summary":"《高性能mysql(第3版)》是mysql 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了最新mysql 5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16 章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql 和mysql相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。\n《高性能mysql(第3版)》不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。","ebook_price":"96.00","price":"128.00元"}