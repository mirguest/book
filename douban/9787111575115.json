{"rating":{"max":10,"numRaters":7,"average":"0.0","min":0},"subtitle":"","author":["约翰·克赛尼希 (John M.Kessenich)","格雷厄姆·塞勒斯 (Grahaam Sellers)","戴夫·施莱尔 (Dave Shreiner)"],"pubdate":"2017-8-1","tags":[{"count":6,"name":"计算机","title":"计算机"},{"count":4,"name":"图形学","title":"图形学"},{"count":4,"name":"OpenGL","title":"OpenGL"},{"count":2,"name":"工作相关","title":"工作相关"},{"count":1,"name":"着色器","title":"着色器"},{"count":1,"name":"渲染","title":"渲染"}],"origin_title":"OpenGL Programming Guide:the Official Guide to Learning OpenGl Version 4.5 with SPIR-V","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29618883.jpg","binding":"平装","translator":["王锐"],"catalog":"推荐语\n译者序\n前言\n致谢\n第1章OpenGL概述\n1.1什么是OpenGL\n1.2初识OpenGL程序\n1.3OpenGL语法\n1.4OpenGL渲染管线\n1.4.1准备向OpenGL传输数据\n1.4.2将数据传输到OpenGL\n1.4.3顶点着色\n1.4.4细分着色\n1.4.5几何着色\n1.4.6图元装配\n1.4.7剪切\n1.4.8光栅化\n1.4.9片元着色\n1.4.10逐片元的操作\n1.5第一个程序：深入分析\n1.5.1进入main（）函数\n1.5.2OpenGL的初始化过程\n1.5.3第一次使用OpenGL进行渲染\n第2章着色器基础\n2.1着色器与OpenGL\n2.2OpenGL的可编程管线\n2.3OpenGL着色语言概述\n2.3.1使用GLSL构建着色器\n2.3.2存储限制符\n2.3.3语句\n2.3.4计算的不变性\n2.3.5着色器的预处理器\n2.3.6编译器的控制\n2.3.7全局着色器编译选项\n2.4数据块接口\n2.4.1uniform块\n2.4.2指定着色器中的uniform块\n2.4.3从应用程序中访问uniform块\n2.4.4buffer块\n2.4.5in／out块、位置和分量\n2.5着色器的编译\n2.6着色器子程序\n2.6.1GLSL的子程序设置\n2.6.2选择着色器于程序\n2.7独立的着色器对象\n2.8SPIR—V\n2.8.1选择SPIR—V的理由\n2.8.2SPIR—V与ODenGL\n2.8.3使用GLSL在OpenGL中生成SPIR—V\n2.8.4Glslang\n2.8.5SPIR—V中包含了什么\n第3章OpenGL绘制方式\n3.1OpenGL图元\n3.1.1点\n3.1.2线、条带与循环线\n3.1.3三角形、条带与扇面\n3.2OpenGL缓存数据\n3.2.1创建与分配缓存\n3.2.2向缓存输入和输出数据\n3.2.3访问缓存的内容\n3.2.4丢弃缓存数据\n3.3顶点规范\n3.3.1深入讨论VertexAttribPointer\n3.3.2静态顶点属性的规范\n3.4OpenGL的绘制命令\n3.4.1图元的重启动\n3.4.2多实例渲染\n第4章颜色、像素和片元\n4.2缓存及其用途\n4.2.1缓存的清除\n4.2.2缓存的掩码\n4.3颜色与OpenGL\n4.3.1颜色的表达与OpenGL\n4.3.2平滑数据插值\n4.4片元的测试与操作\n4.4.1剪切测试\n4.4.2多重采样的片元操作\n4.4.3模板测试\n4.4.4模板的例子\n4.4.5深度测试\n4.4.6融混\n4.4.7逻辑操作\n4.4.8遮挡查询\n4.4.9条件渲染\n4.5多重采样\n4.6逐图元的反走样\n4.6.1线段的反走样\n4.6.2多边形的反走样\n4.7像素数据的读取和拷贝\n4.8拷贝像素矩形\n第5章视口变换、裁减、剪切与反馈\n5.1观察视图\n5.1.1视图模型\n5.1.2相机模型\n5.1.3正交视图模型\n5.2用户变换\n5.2.1矩阵乘法的回顾\n5.2.2齐次坐标\n5.2.3线性变换与矩阵\n5.2.4法线变换\n5.2.5OpenGL矩阵\n5.3OpenGL变换\n5.3.1高级技巧：用户裁减和剪切\n5.3.2OpenGL变换的控制\n5.4transformfeedbaCk\n5.4.1transformfeedback对象\n5.4.2transformfeedback缓存\n5.4.3配置transformfeedback的变量\n5.4.4transformfeedback的启动和停止\n5.4.5transformfeedback的示例：粒子系统\n第6章纹理与帧缓存\n6.1纹理综述\n6.2基本纹理类型\n6.3创建并初始化纹理\n6.4指定纹理数据\n6.4.1显式设置纹理数据\n6.4.2从缓存中加载纹理\n6.4.3从文件加载图像\n6.4.4获取纹理数据\n6.4.5纹理数据的排列布局\n6.5纹理格式\n6.5.1内部格式\n6.5.2外部格式\n6.6压缩纹理\n6.7采样器对象\n6.8纹理的使用\n6.8.1纹理坐标\n6.8.2排列纹理数据\n6.8.3使用多重纹理\n6.9复杂纹理类型\n6.9.13D纹理\n6.9.2纹理数组\n6.9.3立方体映射纹理\n6.9.4阴影采样器\n6.9.5深度—模板纹理\n6.9.6缓存纹理\n6.10纹理视图\n6.11滤波方式\n6.11.1线性滤波\n6.11.2使用和生成mipmap\n6.11.3计算mipmap层次\n6.11.4mipmap细节层次的控制\n6.12高级纹理查询函数\n6.12.1显式的细节层次控制\n6.12.2显式的梯度设置\n6.12.3带有偏移参数的纹理获取函数\n6.12.4投影纹理\n6.12.5在着色器中执行纹理查询\n6.12.6纹素收集\n6.12.7组合功能的特殊函数\n6.13无绑定纹理\n6.13.1纹理句柄\n6.13.2纹理驻留\n6.13.3采样无绑定纹理\n6.14稀疏纹理\n6.14.1稀疏纹理的数据提交\n6.14.2稀疏纹理的页面\n6.15点精灵\n6.15.1纹理点精灵\n6.15.2控制点的显示\n6.16帧缓存对象\n6.17渲染到纹理贴图\n6.17.1抛弃渲染数据\n6.17.2渲染缓存\n6.17.3创建渲染缓存的存储空间\n6.17.4帧缓存附件\n6.17.5帧缓存的完整性\n6.17.6帧缓存的无效化\n6.17.7多重渲染缓存的同步写入\n6.17.8选择颜色缓存来进行读写操作\n6.17.9双源融混\n6.18本章总结\n6.18.1纹理回顾\n6.18.2纹理的佳实践\n第7章光照与阴影\n7.1光照介绍\n7.2经典光照模型\n7.2.1不同光源类型的片元着色器\n7.2.2将计算移到顶点着色器\n7.2.3多个光源和材质\n7.2.4光照坐标系统\n7.2.5经典光照模型的局限\n7.3光照模型进阶\n7.3.1半球光照\n7.3.2基于图像的光照\n7.3.3球面光照\n7.4阴影映射\n7.4.1创建一张阴影贴图\n7.4.2使用阴影贴图\n第8章程序式纹理\n8.1程序式纹理\n8.1.1规则的花纹\n8.1.2玩具球\n8.1.3晶格\n8.1.4程序式着色方法的总结\n8.2凹凸贴图映射\n8.2.1应用程序设置\n8.2.2顶点着色器\n8.2.3片元着色器\n8.2.4法线贴图\n8.3程序式纹理的反走样\n8.3.1走样的来源\n8.3.2避免走样问题\n8.3.3提高分辨率\n8.3.4高频率的反走样\n8.3.5频率截断\n8.3.6程序式反走样的总结\n8.4噪声\n8.4.1噪声的定义\n8.4.2噪声纹理\n8.4.3权衡\n8.4.4一个简单的噪声着色器\n8.4.5湍流\n8.4.6大理石\n8.4.7黄岗岩\n8.4.8木纹\n8.4.9噪声的总结\n8.5更多信息\n……\n第9章细分着色器\n第10章几何着色器\n第11章内存\n第12章计算着色器\n附录A第三方支持库\n附录BpenGLES与WebGL\n附录C内置GLSL变量与函数\n附录D状态变量\n附录E齐次坐标与变换矩阵\n附录F纹理、帧缓存与渲染缓存的浮点格式\n附录GOpenGL程序的调试与优化\n附录H缓存对象的布局\n术语表","pages":"664","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29618883.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29618883.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29618883.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27123094\/","id":"27123094","publisher":"机械工业出版社","isbn10":"7111575113","isbn13":"9787111575115","title":"OpenGL编程指南(原书第9版)","url":"https:\/\/api.douban.com\/v2\/book\/27123094","alt_title":"OpenGL Programming Guide:the Official Guide to Learning OpenGl Version 4.5 with SPIR-V","author_intro":"作者：（美国）约翰·克赛尼希（John Kessenich） （美国）格雷厄姆·塞勒斯（Graham Sellers） （美国）戴夫·施莱尔（Dave Shreiner） 译者：王锐\n约翰·克赛尼希（John Kessenich）， 来自Google的资深软件工程师、SPIR—V的创立者，自1999年以来就广泛参与到OpenGL和GLSL的Khronos标准开发当中。他是SPIR—V和GLSL标准说明书的主要编写者，并且开发了相关的着色器编译工具和解析器来考察相关标准的可移植性。\n格雷厄姆·塞勒斯（Graham Sellers），来自AMD的软件架构和工程部门，是Khronos API的领导者之一，负责OpenGL ARB中的AMD功能部分。他对OpenGL和VulkanWJ核心标准和扩展都做出了贡献，并且持有图形学和图像处理方面的一些专利。\n戴夫·施莱尔（Dave Shreiner），一位有着25年经验的计算机图形工作者，编写和教授计算机图形API相关的课程，并且一直是数本Addison—Wesley出版的计算机图形学图书的核心作者，从事相关写作已有近10年之久。","summary":"《OpenGL编程指南(原书第9版)》共12章，第1章概述OpenGL主要特性和功能；第2章讨论OpenGL中最主要的特性一一可编程着色器和SPIR—V；第3章介绍使用OpenGL进行几何体绘制的各种方法，以及一些可以让渲染更为高效的优化手段；第4章阐释OpenGL对于颜色的处理过程；第5章介绍在一个二维计算机屏幕上表现三维场景的操作细节；第6章讨论将几何模型与图像结合来创建真实的、高质量的三维模型的方法；第7章介绍计算机图形的光照效果模拟方法；第8章介绍使用可编程着色器生成纹理和其他表面效果的方法细节；第9章解释OpenGL管理和细分几何表面的着色器功能；第10章介绍在OpenGL渲染流水线中使用着色器进行几何体图元修改的特别技术；第11章介绍使用OpenGL帧缓存和缓存内存实现高级渲染技术和非图形学应用的相关方法；第12章介绍了最新的着色器阶段，将通用计算的方法融合到OpenGL的渲染流水线当中。","series":{"id":"12919","title":"华章程序员书库"},"price":"CNY 139.00"}