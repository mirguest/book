{"rating":{"max":10,"numRaters":285,"average":"8.9","min":0},"subtitle":"","author":["斯坦利•B.李普曼 (Stanley B. Lippman)"],"pubdate":"2012-1","tags":[{"count":321,"name":"C++","title":"C++"},{"count":109,"name":"C\/C++","title":"C\/C++"},{"count":103,"name":"编程","title":"编程"},{"count":68,"name":"经典之作","title":"经典之作"},{"count":60,"name":"面向对象","title":"面向对象"},{"count":58,"name":"计算机","title":"计算机"},{"count":53,"name":"深度探索C++对象模型","title":"深度探索C++对象模型"},{"count":29,"name":"计算机科学","title":"计算机科学"}],"origin_title":"Inside the C++ Object Model","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28286248.jpg","binding":"平装","translator":["侯捷"],"catalog":"本立道生（侯捷 译序）\tIII\n目录\tVII\n前言（Stanley B. Lippman）\tXIII\n第0章  导读（译者的话）\tXXV\n第1章  关于对象（Object Lessons）\t1\n加上封装后的布局成本（Layout Costs for Adding Encapsulation）\t5\n1.1　C++对象模式（The C++ Object Model）\t6\n简单对象模型（A Simple Object Model）\t7\n表格驱动对象模型（A Table-driven Object Model）\t8\nC++对象模型（The C++ Object Model）\t9\n对象模型如何影响程序（How the Object Model Effects Programs）\t13\n1.2  关键词所带来的差异（A Keyword Distinction）\t15\n关键词的困扰\t16\n策略性正确的struct（The Politically Correct Struct）\t19\n1.3  对象的差异（An Object Distinction）\t22\n指针的类型（The Type of a Pointer）\t28\n加上多态之后（Adding Polymorphism）\t29\n第2章  构造函数语意学（The Semantics of Constructors）\t37\n2.1  Default Constructor的构造操作\t39\n“带有Default Constructor”的Member Class Object\t41\n“带有Default Constructor”的Base Class\t44\n“带有一个Virtual Function”的Class\t44\n“带有一个Virtual Base Class”的Class\t46\n总结\t47\n2.2  Copy Constructor的构造操作\t48\nDefault Memberwise Initialization\t49\nBitwise Copy Semantics（位逐次拷贝）\t51\n不要Bitwise Copy Semantics！\t53\n重新设定Virtual Table的指针\t54\n处理Virtual Base Class Subobject\t57\n2.3  程序转化语意学（Program Transformation Semantics）\t60\n显式的初始化操作（Explicit Initialization）\t61\n参数的初始化（Argument Initialization）\t62\n返回值的初始化（Return Value Initialization）\t63\n在使用者层面做优化（Optimization at the User Level）\t65\n在编译器层面做优化（Optimization at the Compiler Level）\t66\nCopy Constructor：要还是不要？\t72\n摘要\t74\n2.4  成员们的初始化队伍（Member Initialization List）\t74\n第3章  Data语意学（The Semantics of Data）\t83\n3.1  Data Member的绑定（The Binding of a Data Member）\t88\n3.2  Data Member的布局（Data Member Layout）\t92\n3.3  Data Member的存取\t94\nStatic Data Members\t95\nNonstatic Data Members\t97\n3.4 “继承”与Data Member\t99\n只要继承不要多态（Inheritance without Polymorphism）\t100\n加上多态（Adding Polymorphism）\t107\n多重继承（Multiple Inheritance）\t112\n虚拟继承（Virtual Inheritance）\t116\n3.5  对象成员的效率（Object Member Efficiency）\t124\n3.6  指向Data Members的指针（Pointer to Data Members）\t129\n“指向Members的指针”的效率问题\t134\n第4章  Function语意学（The Semantics of Function）\t139\n4.1  Member的各种调用方式\t140\nNonstatic Member Functions（非静态成员函数）\t141\nVirtual Member Functions（虚拟成员函数）\t147\nStatic Member Functions（静态成员函数）\t148\n4.2  Virtual Member Functions（虚拟成员函数）\t152\n多重继承下的Virtual Functions\t159\n虚拟继承下的Virtual Functions\t168\n4.3  函数的效能\t170\n4.4  指向Member Function的指针（Pointer-to-Member Functions）\t174\n支持“指向Virtual Member Functions”的指针\t176\n在多重继承之下，指向Member Functions的指针\t178\n“指向Member Functions之指针”的效率\t180\n4.5  Inline Functions\t182\n形式参数（Formal Arguments）\t185\n局部变量（Local Variables）\t186\n第5章  构造、析构、拷贝语意学（Semantics of Construction,\nDestruction, and Copy）\t191\n纯虚函数的存在（Presence of a Pure Virtual Function）\t193\n虚拟规格的存在（Presence of a Virtual Specification）\t194\n虚拟规格中const的存在\t195\n重新考虑class的声明\t195\n5.1 “无继承”情况下的对象构造\t196\n抽象数据类型（Abstract Data Type）\t198\n为继承做准备\t202\n5.2  继承体系下的对象构造\t206\n虚拟继承（Virtual Inheritance）\t210\nvptr初始化语意学（The Semantics of the vptr Initialization）\t213\n5.3  对象复制语意学（Object Copy Semantics）\t219\n5.4  对象的效能（Object Efficiency）\t225\n5.5  析构语意学（Semantics of Destruction）\t231\n第6章  执行期语意学（Runtime Semantics）\t237\n6.1  对象的构造和析构（Object Construction and Destruction）\t240\n全局对象（Global Objects）\t242\n局部静态对象（Local Static Objects）\t247\n对象数组（Array of Objects）\t250\nDefault Constructors和数组\t252\n6.2  new和delete运算符\t254\n针对数组的new语意\t257\nPlacement Operator new的语意\t263\n6.3  临时性对象（Temporary Objects）\t267\n临时性对象的迷思（神话、传说）\t275\n第7章  站在对象模型的尖端（On the Cusp of the Object Model）\t279\n7.1  Template\t280\nTemplate的“实例化”行为（Template Instantiation）\t281\nTemplate的错误报告（Error Reporting within a Template）\t285\nTemplate中的名称决议法（Name Resolution within a Template）\t289\nMember Function的实例化行为（Member Function Instantiation）\t292\n7.2  异常处理（Exception Handling）\t297\nException Handling快速检阅\t298\n对Exception Handling的支持\t303\n7.3  执行期类型识别（Runtime Type Identification，RTTI）\t308\nType-Safe Downcast（保证安全的向下转换操作）\t310\nType-Safe Dynamic Cast（保证安全的动态转换）\t311\nReferences并不是Pointers\t313\nTypeid运算符\t314\n7.4  效率有了，弹性呢？\t318\n动态共享函数库（Dynamic Shared Libraries）\t318\n共享内存（Shared Memory）\t318","pages":"320","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28286248.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28286248.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28286248.jpg"},"alt":"https:\/\/book.douban.com\/subject\/10427315\/","id":"10427315","publisher":"电子工业出版社","isbn10":"7121149524","isbn13":"9787121149528","title":"深度探索C++对象模型","url":"https:\/\/api.douban.com\/v2\/book\/10427315","alt_title":"Inside the C++ Object Model","author_intro":"Stanley B.Lippman\n\n    微软公司Visual C++ 团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne Stroustrup一起从事C++的设计与开发。他还著有Inside the C++ Object Model。","summary":"作者Lippman参与设计了全世界第一套C++编译程序cfront，这本书就是一位伟大的C++编译程序设计者向你阐述他如何处理各种explicit（明确出现于C++程序代码中）和implicit（隐藏于程序代码背后）的C++语意。\n本书专注于C++面向对象程序设计的底层机制，包括结构式语意、临时性对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承。这本书让你知道：一旦你能够了解底层实现模型，你的程序代码将获得多么大的效率。Lippman澄清了那些关于C++额外负荷与复杂度的各种错误信息和迷思，但也指出其中某些成本和利益交换确实存在。他阐述了各式各样的实现模型，指出它们的进化之道及其本质因素。书中涵盖了C++对象模型的语意暗示，并指出这个模型是如何影响你的程序的。\n对于C++底层机制感兴趣的读者，这必然是一本让你大呼过瘾的绝妙好书。","series":{"id":"6628","title":"传世经典书丛"},"price":"69.00元"}