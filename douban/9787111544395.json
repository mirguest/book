{"rating":{"max":10,"numRaters":13,"average":"8.6","min":0},"subtitle":"第4部分：标准库","author":["Bjarne Stroustrup"],"pubdate":"2016-9","tags":[{"count":14,"name":"C++","title":"C++"},{"count":5,"name":"计算机","title":"计算机"},{"count":2,"name":"计算机科学","title":"计算机科学"},{"count":2,"name":"经典","title":"经典"},{"count":2,"name":"C\/C++","title":"C\/C++"},{"count":1,"name":"計算機","title":"計算機"},{"count":1,"name":"自然科学","title":"自然科学"},{"count":1,"name":"编程","title":"编程"}],"origin_title":"The C++ Programming Language, Fourth Edition","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29114964.jpg","binding":"平装","translator":["王刚","杨巨峰"],"catalog":"出版者的话\n译者序\n前言\n第3版前言\n第2版前言\n第1版前言\n第四部分　标准库\n第30章　标准库概览 2\n30.1　引言 2\n30.1.1　标准库设施 2\n30.1.2　设计约束 4\n30.1.3　描述风格 4\n30.2　头文件 5\n30.3　语言支持 9\n30.3.1　initializer_list支持 9\n30.3.2　范围for支持 10\n30.4　错误处理 10\n30.4.1　异常 10\n30.4.2　断言 14\n30.4.3　system_error 15\n30.5　建议 23\n第31章　STL容器 24\n31.1　引言 24\n31.2　容器概览 24\n31.2.1　容器表示 27\n31.2.2　对元素的要求 28\n31.3　操作概览 30\n31.3.1　成员类型 32\n31.3.2　构造函数、析构函数和赋值操作 33\n31.3.3　大小和容量 34\n31.3.4　迭代器 35\n31.3.5　元素访问 36\n31.3.6　栈操作 36\n31.3.7　列表操作 37\n31.3.8　其他操作 38\n31.4　容器 38\n31.4.1　vector 38\n31.4.2　链表 42\n31.4.3　关联容器 44\n31.5　容器适配器 53\n31.5.1　stack 54\n31.5.2　queue 55\n31.5.3　priority_queue 56\n31.6　建议 57\n第32章　STL算法 59\n32.1　引言 59\n32.2　算法 59\n32.2.1　序列 60\n32.3　策略实参 61\n32.3.1　复杂性 62\n32.4　不修改序列的算法 63\n32.4.1　for_each() 63\n32.4.2　序列谓词 63\n32.4.3　count() 63\n32.4.4　find() 64\n32.4.5　equal()和mismatch() 64\n32.4.6　search() 65\n32.5　修改序列的算法 66\n32.5.1　copy() 66\n32.5.2　unique() 67\n32.5.3　remove()和replace() 68\n32.5.4　rotate()、random_shuffle()和partition() 69\n32.5.5　排列 70\n32.5.6　fill() 70\n32.5.7　swap() 71\n32.6　排序和搜索 71\n32.6.1　二分搜索 74\n32.6.2　merge() 75\n32.6.3　集合算法 75\n32.6.4　堆 76\n32.6.5　lexicographical_compare() 77\n32.7　最大值和最小值 78\n32.8　建议 79\n第33章　STL迭代器 80\n33.1　引言 80\n33.1.1　迭代器模型 80\n33.1.2　迭代器类别 81\n33.1.3　迭代器萃取 82\n33.1.4　迭代器操作 85\n33.2　迭代器适配器 85\n33.2.1　反向迭代器 86\n33.2.2　插入迭代器 88\n33.2.3　移动迭代器 89\n33.3　范围访问函数 89\n33.4　函数对象 90\n33.5　函数适配器 91\n33.5.1　bind() 92\n33.5.2　mem_fn() 93\n33.5.3　function 93\n33.6　建议 95\n第34章　内存和资源 96\n34.1　引言 96\n34.2　“拟容器” 96\n34.2.1　array 97\n34.2.2　bitset 99\n34.2.3　vector 103\n34.2.4　元组 104\n34.3　资源管理指针 107\n34.3.1　unique_ptr 108\n34.3.2　shared_ptr 111\n34.3.3　weak_ptr 113\n34.4　分配器 115\n34.4.1　默认分配器 116\n34.4.2　分配器萃取 118\n34.4.3　指针萃取 119\n34.4.4　限域的分配器 119\n34.5　垃圾收集接口 121\n34.6　未初始化内存 123\n34.6.1　临时缓冲区 123\n34.6.2　raw_storage_iterator 124\n34.7　建议 125\n第35章　工具 126\n35.1　引言 126\n35.2　时间 126\n35.2.1　duration 127\n35.2.2　time_point 129\n35.2.3　时钟 131\n35.2.4　时间萃取 132\n35.3　编译时有理数运算 132\n35.4　类型函数 134\n35.4.1　类型萃取 134\n35.4.2　类型生成器 138\n35.5　其他工具 142\n35.5.1　move()和forward() 142\n35.5.2　swap() 143\n35.5.3　关系运算符 143\n35.5.4　比较和哈希type_info 144\n35.6　建议 145\n第36章　字符串 146\n36.1　引言 146\n36.2　字符分类 146\n36.2.1　分类函数 146\n36.2.2　字符萃取 147\n36.3　字符串 148\n36.3.1　string与C风格字符串 149\n36.3.2　构造函数 151\n36.3.3　基本操作 152\n36.3.4　字符串I\/O 153\n36.3.5　数值转换 154\n36.3.6　类STL操作 155\n36.3.7　find系列函数 157\n36.3.8　子串 158\n36.4　建议 159\n第37章　正则表达式 160\n37.1　正则表达式 160\n37.1.1　正则表达式符号表示 161\n37.2　regex 165\n37.2.1　匹配结果 166\n37.2.2　格式化 169\n37.3　正则表达式函数 170\n37.3.1　regex_match() 170\n37.3.2　regex_search() 171\n37.3.3　regex_replace() 172\n37.4　正则表达式迭代器 173\n37.4.1　regex_iterator 173\n37.4.2　regex_token_iterator 175\n37.5　regex_traits 176\n37.6　建议 177\n第38章　I\/O流 178\n38.1　引言 178\n38.2　I\/O流层次 180\n38.2.1　文件流 180\n38.2.2　字符串流 182\n38.3　错误处理 183\n38.4　I\/O操作 184\n38.4.1　输入操作 185\n38.4.2　输出操作 187\n38.4.3　操纵符 189\n38.4.4　流状态 190\n38.4.5　格式化 194\n38.5　流迭代器 200\n38.6　缓冲 201\n38.6.1　输出流和缓冲区 204\n38.6.2　输入流和缓冲区 205\n38.6.3　缓冲区迭代器 205\n38.7　建议 207\n第39章　区域设置 209\n39.1　处理文化差异 209\n39.2　类locale 211\n39.2.1　命名locale 213\n39.2.2　比较string 216\n39.3　类facet 217\n39.3.1　访问locale中的facet 218\n39.3.2　一个简单的用户自定义facet 218\n39.3.3　locale和facet的使用 221\n39.4　标准facet 221\n39.4.1　string比较 223\n39.4.2　数值格式化 226\n39.4.3　货币格式化 231\n39.4.4　日期和时间格式化 235\n39.4.5　字符分类 238\n39.4.6　字符编码转换 241\n39.4.7　消息 244\n39.5　便利接口 248\n39.5.1　字符分类 248\n39.5.2　字符转换 248\n39.5.3　字符串转换 249\n39.5.4　缓冲区转换 250\n39.6　建议 250\n第40章　数值计算 252\n40.1　引言 252\n40.2　数值限制 252\n40.2.1　数值限制宏 255\n40.3　标准数学函数 255\n40.4　复数complex 257\n40.5　数值数组：valarray 258\n40.5.1　构造函数和赋值操作 258\n40.5.2　下标操作 260\n40.5.3　运算 261\n40.5.4　切片 263\n40.5.5　slice_array 265\n40.5.6　推广切片 265\n40.6　推广数值算法 267\n40.6.1　accumulate() 267\n40.6.2　inner_product() 268\n40.6.3　partial_sum()和adjacent_difference() 269\n40.6.4　iota() 270\n40.7　随机数 270\n40.7.1　引擎 272\n40.7.2　随机设备 274\n40.7.3　分布 274\n40.7.4　C风格随机数 277\n40.8　建议 278\n第41章　并发 279\n41.1　引言 279\n41.2　内存模型 280\n41.2.1　内存位置 281\n41.2.2　指令重排 282\n41.2.3　内存序 282\n41.2.4　数据竞争 283\n41.3　原子性 285\n41.3.1　atomic类型 287\n41.3.2　标志和栅栏 291\n41.4　volatile 292\n41.5　建议 292\n第42章　线程和任务 293\n42.1　引言 293\n42.2　线程 293\n42.2.1　身份 294\n42.2.2　构造 295\n42.2.3　析构 296\n42.2.4　join() 297\n42.2.5　detach() 298\n42.2.6　名字空间this_thread 299\n42.2.7　杀死thread 300\n42.2.8　thread_local数据 300\n42.3　避免数据竞争 302\n42.3.1　互斥量 302\n42.3.2　多重锁 309\n42.3.3　call_once() 311\n42.3.4　条件变量 311\n42.4　基于任务的并发 315\n42.4.1　future和promise 316\n42.4.2　promise 317\n42.4.3　packaged_task 318\n42.4.4　future 320\n42.4.5　shared_future 323\n42.4.6　async() 323\n42.4.7　一个并行find()示例 325\n42.5　建议 328\n第43章　C标准库 330\n43.1　引言 330\n43.2　文件 330\n43.3　printf()系列函数 331\n43.4　C风格字符串 334\n43.5　内存 335\n43.6　日期和时间 336\n43.7　杂项 339\n43.8　建议 340\n第44章　兼容性 341\n44.1　引言 341\n44.2　C++11扩展 341\n44.2.1　语言特性 341\n44.2.2　标准库组件 343\n44.2.3　弃用特性 344\n44.2.4　应对旧版本C++实现 344\n44.3　C\/C++兼容性 345\n44.3.1　C和C++是兄弟 345\n44.3.2　“静默”差异 346\n44.3.3　不兼容C++的C代码 347\n44.3.4　不兼容C的C++代码 350\n44.4　建议 351","pages":"352","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29114964.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29114964.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29114964.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26900000\/","id":"26900000","publisher":"机械工业出版社","isbn10":"7111544390","isbn13":"9787111544395","title":"C++ 程序设计语言（第 4 部分：标准库）（原书第 4 版）","url":"https:\/\/api.douban.com\/v2\/book\/26900000","alt_title":"The C++ Programming Language, Fourth Edition","author_intro":"本贾尼·斯特劳斯特鲁普\n（Bjarne Stroustrup）\nC++语言的设计者和最初实现者，C++语言ISO标准化工作的积极参与者，同时也是《C++程序设计语言》和《C++程序设计原理与实践》的作者。他是英国剑桥大学计算机科学专业博士，1979年加入美国新泽西贝尔实验室，从成立到2002年一直担任贝尔实验室大规模程序设计研究部门的负责人。2002年至2014年，Bjarne被评为德州农工大学工程学院计算机科学首席教授，哥伦比亚大学计算机科学系客座教授，德州农工大学计算机","summary":"C++语言之父的经典名著之最新版本，全面掌握标准C++11及其编程技术的权威指南！\n第1版1985年，第2版1991年，第3版1997年，特别版2000年，第4版2013年，经典无限延伸……\n本书是在C++语言和程序设计领域具有深远影响、畅销不衰的经典著作，由C++语言的设计者和最初的实现者Bjarne Stroustrup编写，对C++语言进行了最全面、最权威的论述，覆盖标准C++以及由C++所支持的关键编程技术和设计技术。本书英文原版一经面世，即引起业内人士的高度评价和热烈欢迎，先后被翻译成德、希、匈、西、荷、法、日、俄、中、韩等近20种语言，数以百万计的程序员从中获益，是无可取代的C++经典力作。\n新的C++11标准使得程序员能以更清晰、更简明、更直接的方式表达思想，从而编写出更快速和高效的代码。在最新出版的第4版中，Stroustrup博士针对最新的C++11标准，为所有希望更有效使用C++语言编程的程序员重新组织、扩展和全面重写了这本C++语言的权威参考书和学习指南，细致、全面、综合地阐述了C++语言及其基本特性、抽象机制、标准库和关键设计技术。\n新的C++11标准的内容包括\n支持并发处理。\n正则表达式、资源管理指针、随机数、改进的容器（包括哈希表）以及其他很多特性。\n通用和一致的初始化机制、更简单的for语句、移动语义、基础的Unicode支持。\nlambda表达式、通用常量表达式、控制类缺省定义的能力、可变参数模板、模板别名、用户定义的字面值常量。\n兼容性问题。","series":{"id":"1163","title":"计算机科学丛书"},"price":"89.00元"}